#if !NET35 && !PCL
#define SUPPORTS_SPIN_WAIT
#endif

#if !NET35 && !PCL
#define SUPPORTS_LAZY
#endif

using System;
using System.Collections.Generic;
using ImTools.Experimental;
using Xunit;
using CsCheck;
using System.Linq;
using ImTools;

#pragma warning disable

namespace Tests
{
    public class IMToolsTests
    {
        [Fact]
        public void ModelEqual_ImHashMap234()
        {
            Assert.True(Check.ModelEqual(
                ImHashMap234<int, int>.Empty.AddOrUpdate(1, 2).AddOrUpdate(3, 4)
                .Enumerate().Select(kv => ImTools.KeyValuePair.Pair(kv.Key, kv.Value)),
                new Dictionary<int, int> { {3, 4}, {1, 2 } }
            ));
        }


        [Fact(Skip = "Experiment")]
        public void AddOrUpdate_random_items_and_randomly_checking()
        {
            const int upperBound = 100000;
            var savedSeed = new Random().Next(0, upperBound);
            var rnd = new Random(savedSeed);

            var m = ImHashMap234<int, int>.Empty;
            for (var i = 0; i < 5000; i++)
            {
                var n = rnd.Next(0, upperBound);
                m = m.AddOrUpdate(n, n);
                Assert.Equal(n, m.GetValueOrDefault(n));
            }

            // non-existing keys 
            Assert.Equal(0, m.GetValueOrDefault(upperBound + 1));
            Assert.Equal(0, m.GetValueOrDefault(-1));
        }

        [Fact(Skip = "Experiment")]
        public void AddOrUpdate_random_items_and_randomly_checking_CsCheck()
        {
            const int upperBound = 11966;
            Gen.Int[0, upperBound].Array[1, 12].Sample(ints =>
            {
                var m = ImHashMap234<int, int>.Empty;
                foreach (var n in ints)
                {
                    m = m.AddOrUpdate(n, n);
                    Assert.Equal(n, m.GetValueOrDefault(n));
                }
                Assert.Equal(0, m.GetValueOrDefault(upperBound + 1));
                Assert.Equal(0, m.GetValueOrDefault(-1));
            }, iter: 1_000/*, seed: "2Tt3UJ9PI4Hs3"*/);
        }

        static Gen<ImHashMap234<int, int>> GenMap(int upperBound) =>
            Gen.Int[0, upperBound].ArrayUnique.SelectMany(ks =>
                Gen.Int.Array[ks.Length].Select(vs =>
                {
                    var m = ImHashMap234<int, int>.Empty;
                    for (int i = 0; i < ks.Length; i++)
                        m = m.AddOrUpdate(ks[i], vs[i]);
                    return m;
                }));

        class ImHolder<T> { public T Im; }

        [Fact(Skip = "Experiment")]
        public void AddOrUpdate_Metamorphic()
        {
            const int upperBound = 100000;
            GenMap(upperBound)
            .Select(i => new ImHolder<ImHashMap234<int, int>> { Im = i })
            .SampleMetamorphic(
                Gen.Select(Gen.Int[0, upperBound], Gen.Int, Gen.Int[0, upperBound], Gen.Int).Metamorphic<ImHolder<ImHashMap234<int, int>>>(
                    (d, t) => d.Im = d.Im.AddOrUpdate(t.Item1, t.Item2).AddOrUpdate(t.Item3, t.Item4),
                    (d, t) => d.Im = t.Item1 == t.Item3 ? d.Im.AddOrUpdate(t.Item3, t.Item4) : d.Im.AddOrUpdate(t.Item3, t.Item4).AddOrUpdate(t.Item1, t.Item2)
                )
                , equal: (a, b) => Check.Equal(a.Im.Enumerate().Select(j => (j.Key, j.Value)), b.Im.Enumerate().Select(j => (j.Key, j.Value)))
                , print: i => Check.Print(i.Im.Enumerate().Select(j => (j.Key, j.Value)))
            );
        }

        [Fact(Skip = "Experiment")]
        public void AddOrUpdate_ModelBased()
        {
            const int upperBound = 100000;
            GenMap(upperBound).Select(d =>
            {
                var m = new Dictionary<int, int>();
                foreach (var entry in d.Enumerate()) m[entry.Key] = entry.Value;
                return (new ImHolder<ImHashMap234<int, int>> { Im = d }, m);
            })
            .SampleModelBased(
                Gen.Int[0, upperBound].Select(Gen.Int).Operation<ImHolder<ImHashMap234<int, int>>, Dictionary<int, int>>((h, d, kv) =>
                {
                    h.Im = h.Im.AddOrUpdate(kv.Item1, kv.Item2);
                    d[kv.Item1] = kv.Item2;
                })
                , equal: (h, d) =>
                {
                    var he = h.Im.Enumerate().Select(kv => (kv.Key, kv.Value)).ToList();
                    return he.Count == d.Count && !he.Except(d.Select(kv => (kv.Key, kv.Value))).Any();
                }
                , printActual: h => Check.Print(h.Im.Enumerate().Select(kv => (kv.Key, kv.Value)))
                , iter: 100_000
            );
        }
    }


}

// <auto-generated/>
/*
The MIT License (MIT)

Copyright (c) 2016-2020 Maksim Volkau

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

// ReSharper disable once InconsistentNaming

namespace ImTools
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading;
    using System.Runtime.CompilerServices; // For [MethodImpl(AggressiveInlining)]

    /// <summary>Helpers for functional composition</summary>
    public static class Fun
    {
        /// <summary>
        /// Always a true condition.
        /// </summary> 
        public static bool Always<T>(T _) => true;

        /// <summary>
        /// Identity function returning passed argument as result.
        /// </summary> 
        public static T Id<T>(T x) => x;

        /// <summary>
        /// Forward pipe operator (`|>` in F#)
        /// </summary> 
        public static R To<T, R>(this T x, Func<T, R> map) => map(x);

        /// <summary>
        /// Forward pipe operator (`|>` in F#) with the additional state A for two arguments function
        /// </summary> 
        public static R To<T, S, R>(this T x, S state, Func<T, S, R> map) => map(x, state);

        /// <summary>
        /// Cast to the R type with the forward pipe operator (`|>` in F#)
        /// </summary> 
        public static R To<R>(this object x) => (R)x;

        /// <summary>
        /// Forward pipe operator (`|>` in F#) but with side effect propagating the original `x` value
        /// </summary> 
        public static T Do<T>(this T x, Action<T> effect)
        {
            effect(x);
            return x;
        }

        /// <summary>
        /// Forward pipe operator (`|>` in F#) but with side effect propagating the original `x` value and the state object
        /// </summary> 
        public static T Do<T, S>(this T x, S state, Action<T, S> effect)
        {
            effect(x, state);
            return x;
        }

        /// <summary>
        /// Lifts argument to Func without allocations ignoring the first argument.
        /// For example if you have `Func{T, R} = _ => instance`,
        /// you may rewrite it without allocations as `instance.ToFunc{A, R}`
        /// </summary> 
        public static R ToFunc<T, R>(this R result, T ignoredArg) => result;
    }

#if SUPPORTS_LAZY
    /// <summary>Helpers for lazy instantiations</summary>
    public static class Lazy
    {
        /// <summary>Provides result type inference for creation of lazy.</summary>
        public static Lazy<T> Of<T>(Func<T> valueFactory) => new Lazy<T>(valueFactory);
    }
#endif

    /// Replacement for `Void` type which can be used as a type argument and value.
    /// In traditional functional languages this type is a singleton empty record type,
    /// e.g. `()` in Haskell https://en.wikipedia.org/wiki/Unit_type
    public struct Unit : IEquatable<Unit>
    {
        /// Singleton unit value - making it a lower-case so you could import `using static ImTools.Unit;` and write `return unit;`
        public static readonly Unit unit = new Unit();

        /// <inheritdoc />
        public override string ToString() => "(unit)";

        /// Equals to any other Unit
        public bool Equals(Unit other) => true;

        /// <inheritdoc />
        public override bool Equals(object obj) => obj is Unit;

        /// Using type hash code for the value
        public override int GetHashCode() => typeof(Unit).GetHashCode();
    }

    /// Simple value provider interface - useful for the type pattern matching via `case I{T} x: ...`
    public interface I<out T>
    {
        /// The value in this case ;)
        T Value { get; }
    }

    /// Helpers for `Is` and `Union`
    public static class UnionTools
    {
        /// Pretty prints the Union using the type information
        internal static string ToString<TName, T>(T value, string prefix = "case(", string suffix = ")")
        {
            if (typeof(TName) == typeof(Unit))
                return prefix + value + suffix;

            var typeName = typeof(TName).Name;
            var i = typeName.IndexOf('`');
            var name = i == -1 ? typeName : typeName.Substring(0, i);
            return name + prefix + value + suffix;
        }
    }

    /// Wraps the `T` in a typed `TData` struct value in a one-line declaration,
    /// so the <c><![CDATA[class Name : Case<Name, string>]]></c>
    /// is different from the <c><![CDATA[class Address : Case<Address, string>]]></c> 
    public abstract class Item<TItem, T> where TItem : Item<TItem, T>
    {
        /// Creation method for the consistency with other types
        public static item Of(T x) => new item(x);

        /// Nested structure that hosts a value.
        /// All nested types by convention here are lowercase
        public readonly struct item : IEquatable<item>, I<T>
        {
            /// <inheritdoc />
            public T Value { [MethodImpl((MethodImplOptions)256)] get => Item; }

            /// The value
            public readonly T Item;

            /// Constructor
            public item(T x) => Item = x;

            /// <inheritdoc />
            public bool Equals(item other) => EqualityComparer<T>.Default.Equals(Value, other.Value);

            /// <inheritdoc />
            public override bool Equals(object obj) => obj is item c && Equals(c);

            /// <inheritdoc />
            public override int GetHashCode() => EqualityComparer<T>.Default.GetHashCode(Value);

            /// <inheritdoc />
            public override string ToString() => UnionTools.ToString<TItem, T>(Value);
        }
    }

    /// Item without the data payload
    public abstract class Item<TItem> where TItem : Item<TItem>
    {
        /// Single item value
        public static readonly item Value = new item();

        /// Nested structure that hosts a value.
        /// All nested types by convention here are lowercase
        public readonly struct item : IEquatable<item>
        {
            /// <inheritdoc />
            public bool Equals(item other) => true;

            /// <inheritdoc />
            public override bool Equals(object obj) => obj is item;

            /// <inheritdoc />
            public override int GetHashCode() => typeof(TItem).GetHashCode();

            /// <inheritdoc />
            public override string ToString() => "(" + typeof(TItem).Name + ")";
        }
    }

    /// Wraps the `T` in a named `TBox` class in a one-line declaration,
    /// so the <c><![CDATA[class Name : Box<Name, string>]]></c>
    /// is different from the <c><![CDATA[class Address : Box<Address, string>]]></c> 
    public abstract class Box<TBox, T> : I<T>, IEquatable<Box<TBox, T>>
        where TBox : Box<TBox, T>, new()
    {
        /// Wraps the value
        public static TBox Of(T x) => new TBox { Value = x };

        /// <inheritdoc />
        public T Value { get; private set; }

        /// <inheritdoc />
        public bool Equals(Box<TBox, T> other) =>
            other is not null && EqualityComparer<T>.Default.Equals(Value, other.Value);

        /// <inheritdoc />
        public override bool Equals(object obj) => obj is Box<TBox, T> c && Equals(c);

        // ReSharper disable once NonReadonlyMemberInGetHashCode
        /// <inheritdoc />
        public override int GetHashCode() => EqualityComparer<T>.Default.GetHashCode(Value);

        /// <inheritdoc />
        public override string ToString() => UnionTools.ToString<TBox, T>(Value, "box(");
    }

    /// Unnamed discriminated union (with Empty name), shorter name for simplified inline usage
    public class U<T1, T2> : Union<Unit, T1, T2> { }

    /// Discriminated union
    public abstract class Union<TUnion, T1, T2>
    {
        /// To tag the cases with enum value for efficient pattern matching of required -
        /// otherwise we need to use `is CaseN` pattern or similar which is less efficient
        public enum Tag : byte
        {
            /// Tags Case1
            Case1,
            /// Tags Case2
            Case2
        }

        /// The base interface for the cases to operate.
        /// The naming is selected to start from the lower letter, cause we need to use the nested type.
        /// It is an unusual case, that's why using the __union__ will be fine to highlight this.
        // ReSharper disable once InconsistentNaming
        public interface union
        {
            /// The tag
            Tag Tag { get; }

            /// Matches the union cases to the R value
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2);
        }

        /// Creates the respective case
        public static union Of(T1 x) => new case1(x);

        /// Creates the respective case
        public static union Of(T2 x) => new case2(x);

        /// Wraps the respective case
        public readonly struct case1 : union, IEquatable<case1>, I<T1>
        {
            /// Implicit conversion
            public static implicit operator case1(T1 x) => new case1(x);

            /// <inheritdoc />
            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

            /// <inheritdoc />
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2) => map1(Case);

            /// <inheritdoc />
            public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            /// The case value
            public readonly T1 Case;

            /// Wraps the value
            public case1(T1 x) => Case = x;

            /// <inheritdoc />
            public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Value, other.Value);

            /// <inheritdoc />
            public override bool Equals(object obj) => obj is case1 x && Equals(x);

            /// <inheritdoc />
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Value);

            /// <inheritdoc />
            public override string ToString() => UnionTools.ToString<TUnion, T1>(Value);
        }

        /// Wraps the respective case
        public readonly struct case2 : union, IEquatable<case2>, I<T2>
        {
            /// Conversion
            public static implicit operator case2(T2 x) => new case2(x);

            /// <inheritdoc />
            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }

            /// <inheritdoc />
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2) => map2(Value);

            /// <inheritdoc />
            public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            /// The case value
            public readonly T2 Case;

            /// Wraps the value
            public case2(T2 x) => Case = x;

            /// <inheritdoc />
            public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Value, other.Value);

            /// <inheritdoc />
            public override bool Equals(object obj) => obj is case2 x && Equals(x);

            /// <inheritdoc />
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Value);

            /// <inheritdoc />
            public override string ToString() => UnionTools.ToString<TUnion, T2>(Value);
        }
    }

#pragma warning disable 1591
    public class U<T1, T2, T3> : Union<Unit, T1, T2, T3> { }

    public abstract class Union<TUnion, T1, T2, T3>
    {
        public enum Tag : byte { Case1, Case2, Case3 }

        public interface union
        {
            Tag Tag { get; }
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3);
        }

        public static union Of(T1 x) => new case1(x);
        public static union Of(T2 x) => new case2(x);
        public static union Of(T3 x) => new case3(x);

        public struct case1 : union, IEquatable<case1>, I<T1>
        {
            public static implicit operator case1(T1 x) => new case1(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

            [MethodImpl((MethodImplOptions)256)]
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3) => map1(Case);

            public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T1 Case;
            public case1(T1 x) => Case = x;

            public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case1 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
        }

        public struct case2 : union, IEquatable<case2>, I<T2>
        {
            public static implicit operator case2(T2 x) => new case2(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3) => map2(Case);

            public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T2 Case;
            public case2(T2 x) => Case = x;

            public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case2 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
        }

        public struct case3 : union, IEquatable<case3>, I<T3>
        {
            public static implicit operator case3(T3 x) => new case3(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3) => map3(Case);

            public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T3 Case;
            public case3(T3 x) => Case = x;

            public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case3 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
        }
    }

    public class U<T1, T2, T3, T4> : Union<Unit, T1, T2, T3, T4> { }
    public abstract class Union<TUnion, T1, T2, T3, T4>
    {
        public enum Tag : byte { Case1, Case2, Case3, Case4 }

        public interface union
        {
            Tag Tag { get; }
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4);
        }

        public static union Of(T1 x) => new case1(x);
        public static union Of(T2 x) => new case2(x);
        public static union Of(T3 x) => new case3(x);
        public static union Of(T4 x) => new case4(x);

        public struct case1 : union, IEquatable<case1>, I<T1>
        {
            public static implicit operator case1(T1 x) => new case1(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

            [MethodImpl((MethodImplOptions)256)]
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4) => map1(Case);

            public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T1 Case;
            public case1(T1 x) => Case = x;

            public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case1 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
        }

        public struct case2 : union, IEquatable<case2>, I<T2>
        {
            public static implicit operator case2(T2 x) => new case2(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4) => map2(Case);

            public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T2 Case;
            public case2(T2 x) => Case = x;

            public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case2 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
        }

        public struct case3 : union, IEquatable<case3>, I<T3>
        {
            public static implicit operator case3(T3 x) => new case3(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4) => map3(Case);

            public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T3 Case;
            public case3(T3 x) => Case = x;

            public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case3 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
        }

        public struct case4 : union, IEquatable<case4>, I<T4>
        {
            public static implicit operator case4(T4 x) => new case4(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case4; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4) => map4(Case);

            public T4 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T4 Case;
            public case4(T4 x) => Case = x;

            public bool Equals(case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case4 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T4>(Case);
        }
    }

    public class U<T1, T2, T3, T4, T5> : Union<Unit, T1, T2, T3, T4, T5> { }
    public abstract class Union<TUnion, T1, T2, T3, T4, T5>
    {
        public enum Tag : byte { Case1, Case2, Case3, Case4, Case5 }

        public interface union
        {
            Tag Tag { get; }
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5);
        }

        public static union Of(T1 x) => new case1(x);
        public static union Of(T2 x) => new case2(x);
        public static union Of(T3 x) => new case3(x);
        public static union Of(T4 x) => new case4(x);
        public static union Of(T5 x) => new case5(x);

        public struct case1 : union, IEquatable<case1>, I<T1>
        {
            public static implicit operator case1(T1 x) => new case1(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

            [MethodImpl((MethodImplOptions)256)]
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5) => map1(Case);

            public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T1 Case;
            public case1(T1 x) => Case = x;

            public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case1 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
        }

        public struct case2 : union, IEquatable<case2>, I<T2>
        {
            public static implicit operator case2(T2 x) => new case2(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5) => map2(Case);

            public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T2 Case;
            public case2(T2 x) => Case = x;

            public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case2 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
        }

        public struct case3 : union, IEquatable<case3>, I<T3>
        {
            public static implicit operator case3(T3 x) => new case3(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5) => map3(Case);

            public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T3 Case;
            public case3(T3 x) => Case = x;

            public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case3 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
        }

        public struct case4 : union, IEquatable<case4>, I<T4>
        {
            public static implicit operator case4(T4 x) => new case4(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case4; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5) => map4(Case);

            public T4 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T4 Case;
            public case4(T4 x) => Case = x;

            public bool Equals(case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case4 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T4>(Case);
        }

        public struct case5 : union, IEquatable<case5>, I<T5>
        {
            public static implicit operator case5(T5 x) => new case5(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case5; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5) => map5(Case);

            public T5 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T5 Case;
            public case5(T5 x) => Case = x;

            public bool Equals(case5 other) => EqualityComparer<T5>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case5 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T5>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T5>(Case);
        }
    }

    public class U<T1, T2, T3, T4, T5, T6> : Union<Unit, T1, T2, T3, T4, T5, T6> { }
    public abstract class Union<TUnion, T1, T2, T3, T4, T5, T6>
    {
        public enum Tag : byte { Case1, Case2, Case3, Case4, Case5, Case6 }

        public interface union
        {
            Tag Tag { get; }
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6);
        }

        public static union Of(T1 x) => new case1(x);
        public static union Of(T2 x) => new case2(x);
        public static union Of(T3 x) => new case3(x);
        public static union Of(T4 x) => new case4(x);
        public static union Of(T5 x) => new case5(x);
        public static union Of(T6 x) => new case6(x);

        public struct case1 : union, IEquatable<case1>, I<T1>
        {
            public static implicit operator case1(T1 x) => new case1(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

            [MethodImpl((MethodImplOptions)256)]
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6) => map1(Case);

            public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T1 Case;
            public case1(T1 x) => Case = x;

            public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case1 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
        }

        public struct case2 : union, IEquatable<case2>, I<T2>
        {
            public static implicit operator case2(T2 x) => new case2(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6) => map2(Case);

            public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T2 Case;
            public case2(T2 x) => Case = x;

            public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case2 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
        }

        public struct case3 : union, IEquatable<case3>, I<T3>
        {
            public static implicit operator case3(T3 x) => new case3(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6) => map3(Case);

            public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T3 Case;
            public case3(T3 x) => Case = x;

            public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case3 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
        }

        public struct case4 : union, IEquatable<case4>, I<T4>
        {
            public static implicit operator case4(T4 x) => new case4(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case4; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6) => map4(Case);

            public T4 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T4 Case;
            public case4(T4 x) => Case = x;

            public bool Equals(case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case4 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T4>(Case);
        }

        public struct case5 : union, IEquatable<case5>, I<T5>
        {
            public static implicit operator case5(T5 x) => new case5(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case5; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6) => map5(Case);

            public T5 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T5 Case;
            public case5(T5 x) => Case = x;

            public bool Equals(case5 other) => EqualityComparer<T5>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case5 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T5>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T5>(Case);
        }

        public struct case6 : union, IEquatable<case6>, I<T6>
        {
            public static implicit operator case6(T6 x) => new case6(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case6; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6) => map6(Case);

            public T6 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T6 Case;
            public case6(T6 x) => Case = x;

            public bool Equals(case6 other) => EqualityComparer<T6>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case6 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T6>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T6>(Case);
        }
    }

    public class U<T1, T2, T3, T4, T5, T6, T7> : Union<Unit, T1, T2, T3, T4, T5, T6, T7> { }
    public abstract class Union<TUnion, T1, T2, T3, T4, T5, T6, T7>
    {
        public enum Tag : byte { Case1, Case2, Case3, Case4, Case5, Case6, Case7 }

        public interface union
        {
            Tag Tag { get; }
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7);
        }

        public static union Of(T1 x) => new case1(x);
        public static union Of(T2 x) => new case2(x);
        public static union Of(T3 x) => new case3(x);
        public static union Of(T4 x) => new case4(x);
        public static union Of(T5 x) => new case5(x);
        public static union Of(T6 x) => new case6(x);
        public static union Of(T7 x) => new case7(x);

        public struct case1 : union, IEquatable<case1>, I<T1>
        {
            public static implicit operator case1(T1 x) => new case1(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

            [MethodImpl((MethodImplOptions)256)]
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7) => map1(Case);

            public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T1 Case;
            public case1(T1 x) => Case = x;

            public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case1 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
        }

        public struct case2 : union, IEquatable<case2>, I<T2>
        {
            public static implicit operator case2(T2 x) => new case2(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7) => map2(Case);

            public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T2 Case;
            public case2(T2 x) => Case = x;

            public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case2 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
        }


        public struct case3 : union, IEquatable<case3>, I<T3>
        {
            public static implicit operator case3(T3 x) => new case3(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7) => map3(Case);

            public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T3 Case;
            public case3(T3 x) => Case = x;

            public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case3 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
        }

        public struct case4 : union, IEquatable<case4>, I<T4>
        {
            public static implicit operator case4(T4 x) => new case4(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case4; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7) => map4(Case);

            public T4 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T4 Case;
            public case4(T4 x) => Case = x;

            public bool Equals(case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case4 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T4>(Case);
        }

        public struct case5 : union, IEquatable<case5>, I<T5>
        {
            public static implicit operator case5(T5 x) => new case5(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case5; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7) => map5(Case);

            public T5 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T5 Case;
            public case5(T5 x) => Case = x;

            public bool Equals(case5 other) => EqualityComparer<T5>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case5 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T5>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T5>(Case);
        }

        public struct case6 : union, IEquatable<case6>, I<T6>
        {
            public static implicit operator case6(T6 x) => new case6(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case6; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7) => map6(Case);

            public T6 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T6 Case;
            public case6(T6 x) => Case = x;

            public bool Equals(case6 other) => EqualityComparer<T6>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case6 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T6>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T6>(Case);
        }

        public struct case7 : union, IEquatable<case7>, I<T7>
        {
            public static implicit operator case7(T7 x) => new case7(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case7; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7) => map7(Case);

            public T7 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T7 Case;
            public case7(T7 x) => Case = x;

            public bool Equals(case7 other) => EqualityComparer<T7>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case7 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T7>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T7>(Case);
        }
    }

    public abstract class Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>
    {
        public enum Tag : byte { Case1, Case2, Case3, Case4, Case5, Case6, Case7, Case8 }

        public interface union
        {
            Tag Tag { get; }
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8);
        }

        public static union Of(T1 x) => new case1(x);
        public static union Of(T2 x) => new case2(x);
        public static union Of(T3 x) => new case3(x);
        public static union Of(T4 x) => new case4(x);
        public static union Of(T5 x) => new case5(x);
        public static union Of(T6 x) => new case6(x);
        public static union Of(T7 x) => new case7(x);
        public static union Of(T8 x) => new case8(x);

        public struct case1 : union, IEquatable<case1>, I<T1>
        {
            public static implicit operator case1(T1 x) => new case1(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

            [MethodImpl((MethodImplOptions)256)]
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map1(Case);

            public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T1 Case;
            public case1(T1 x) => Case = x;

            public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case1 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
        }

        public struct case2 : union, IEquatable<case2>, I<T2>
        {
            public static implicit operator case2(T2 x) => new case2(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map2(Case);

            public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T2 Case;
            public case2(T2 x) => Case = x;

            public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case2 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
        }

        public struct case3 : union, IEquatable<case3>, I<T3>
        {
            public static implicit operator case3(T3 x) => new case3(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map3(Case);

            public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T3 Case;
            public case3(T3 x) => Case = x;

            public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case3 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
        }

        public struct case4 : union, IEquatable<case4>, I<T4>
        {
            public static implicit operator case4(T4 x) => new case4(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case4; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map4(Case);

            public T4 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T4 Case;
            public case4(T4 x) => Case = x;

            public bool Equals(case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case4 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T4>(Case);
        }

        public struct case5 : union, IEquatable<case5>, I<T5>
        {
            public static implicit operator case5(T5 x) => new case5(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case5; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map5(Case);

            public T5 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T5 Case;
            public case5(T5 x) => Case = x;

            public bool Equals(case5 other) => EqualityComparer<T5>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case5 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T5>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T5>(Case);
        }

        public struct case6 : union, IEquatable<case6>, I<T6>
        {
            public static implicit operator case6(T6 x) => new case6(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case6; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map6(Case);

            public T6 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T6 Case;
            public case6(T6 x) => Case = x;

            public bool Equals(case6 other) => EqualityComparer<T6>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case6 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T6>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T6>(Case);
        }

        public struct case7 : union, IEquatable<case7>, I<T7>
        {
            public static implicit operator case7(T7 x) => new case7(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case7; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map7(Case);

            public T7 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T7 Case;
            public case7(T7 x) => Case = x;

            public bool Equals(case7 other) => EqualityComparer<T7>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case7 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T7>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T7>(Case);
        }

        public struct case8 : union, IEquatable<case8>, I<T8>
        {
            public static implicit operator case8(T8 x) => new case8(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case8; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map8(Case);

            public T8 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T8 Case;
            public case8(T8 x) => Case = x;

            public bool Equals(case8 other) => EqualityComparer<T8>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case8 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T8>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T8>(Case);
        }
    }

    public abstract class Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>
    {
        public enum Tag : byte { Case1, Case2, Case3, Case4, Case5, Case6, Case7, Case8, Case9 }

        public interface union
        {
            Tag Tag { get; }
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9);
        }

        public static union Of(T1 x) => new case1(x);
        public static union Of(T2 x) => new case2(x);
        public static union Of(T3 x) => new case3(x);
        public static union Of(T4 x) => new case4(x);
        public static union Of(T5 x) => new case5(x);
        public static union Of(T6 x) => new case6(x);
        public static union Of(T7 x) => new case7(x);
        public static union Of(T8 x) => new case8(x);
        public static union Of(T9 x) => new case9(x);

        public struct case1 : union, IEquatable<case1>, I<T1>
        {
            public static implicit operator case1(T1 x) => new case1(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

            [MethodImpl((MethodImplOptions)256)]
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map1(Case);

            public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T1 Case;
            public case1(T1 x) => Case = x;

            public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case1 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
        }

        public struct case2 : union, IEquatable<case2>, I<T2>
        {
            public static implicit operator case2(T2 x) => new case2(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map2(Case);

            public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T2 Case;
            public case2(T2 x) => Case = x;

            public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case2 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
        }

        public struct case3 : union, IEquatable<case3>, I<T3>
        {
            public static implicit operator case3(T3 x) => new case3(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map3(Case);

            public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T3 Case;
            public case3(T3 x) => Case = x;

            public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case3 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
        }

        public struct case4 : union, IEquatable<case4>, I<T4>
        {
            public static implicit operator case4(T4 x) => new case4(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case4; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map4(Case);

            public T4 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T4 Case;
            public case4(T4 x) => Case = x;

            public bool Equals(case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case4 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T4>(Case);
        }

        public struct case5 : union, IEquatable<case5>, I<T5>
        {
            public static implicit operator case5(T5 x) => new case5(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case5; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map5(Case);

            public T5 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T5 Case;
            public case5(T5 x) => Case = x;

            public bool Equals(case5 other) => EqualityComparer<T5>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case5 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T5>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T5>(Case);
        }

        public struct case6 : union, IEquatable<case6>, I<T6>
        {
            public static implicit operator case6(T6 x) => new case6(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case6; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map6(Case);

            public T6 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T6 Case;
            public case6(T6 x) => Case = x;

            public bool Equals(case6 other) => EqualityComparer<T6>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case6 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T6>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T6>(Case);
        }

        public struct case7 : union, IEquatable<case7>, I<T7>
        {
            public static implicit operator case7(T7 x) => new case7(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case7; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map7(Case);

            public T7 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T7 Case;
            public case7(T7 x) => Case = x;

            public bool Equals(case7 other) => EqualityComparer<T7>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case7 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T7>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T7>(Case);
        }

        public struct case8 : union, IEquatable<case8>, I<T8>
        {
            public static implicit operator case8(T8 x) => new case8(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case8; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map8(Case);

            public T8 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T8 Case;
            public case8(T8 x) => Case = x;

            public bool Equals(case8 other) => EqualityComparer<T8>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case8 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T8>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T8>(Case);
        }

        public struct case9 : union, IEquatable<case9>, I<T9>
        {
            public static implicit operator case9(T9 x) => new case9(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case9; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map9(Case);

            public T9 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T9 Case;
            public case9(T9 x) => Case = x;

            public bool Equals(case9 other) => EqualityComparer<T9>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case9 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T9>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T9>(Case);
        }
    }

    public abstract class Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
    {
        public enum Tag : byte { Case1, Case2, Case3, Case4, Case5, Case6, Case7, Case8, Case9, Case10 }

        public interface union
        {
            Tag Tag { get; }
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10);
        }

        public static union Of(T1 x) => new case1(x);
        public static union Of(T2 x) => new case2(x);
        public static union Of(T3 x) => new case3(x);
        public static union Of(T4 x) => new case4(x);
        public static union Of(T5 x) => new case5(x);
        public static union Of(T6 x) => new case6(x);
        public static union Of(T7 x) => new case7(x);
        public static union Of(T8 x) => new case8(x);
        public static union Of(T9 x) => new case9(x);
        public static union Of(T10 x) => new case10(x);

        public struct case1 : union, IEquatable<case1>, I<T1>
        {
            public static implicit operator case1(T1 x) => new case1(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

            [MethodImpl((MethodImplOptions)256)]
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map1(Case);

            public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T1 Case;
            public case1(T1 x) => Case = x;

            public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case1 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
        }

        public struct case2 : union, IEquatable<case2>, I<T2>
        {
            public static implicit operator case2(T2 x) => new case2(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map2(Case);

            public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T2 Case;
            public case2(T2 x) => Case = x;

            public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case2 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
        }

        public struct case3 : union, IEquatable<case3>, I<T3>
        {
            public static implicit operator case3(T3 x) => new case3(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map3(Case);

            public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T3 Case;
            public case3(T3 x) => Case = x;

            public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case3 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
        }

        public struct case4 : union, IEquatable<case4>, I<T4>
        {
            public static implicit operator case4(T4 x) => new case4(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case4; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map4(Case);

            public T4 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T4 Case;
            public case4(T4 x) => Case = x;

            public bool Equals(case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case4 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T4>(Case);
        }

        public struct case5 : union, IEquatable<case5>, I<T5>
        {
            public static implicit operator case5(T5 x) => new case5(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case5; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map5(Case);

            public T5 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T5 Case;
            public case5(T5 x) => Case = x;

            public bool Equals(case5 other) => EqualityComparer<T5>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case5 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T5>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T5>(Case);
        }

        public struct case6 : union, IEquatable<case6>, I<T6>
        {
            public static implicit operator case6(T6 x) => new case6(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case6; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map6(Case);

            public T6 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T6 Case;
            public case6(T6 x) => Case = x;

            public bool Equals(case6 other) => EqualityComparer<T6>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case6 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T6>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T6>(Case);
        }

        public struct case7 : union, IEquatable<case7>, I<T7>
        {
            public static implicit operator case7(T7 x) => new case7(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case7; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map7(Case);

            public T7 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T7 Case;
            public case7(T7 x) => Case = x;

            public bool Equals(case7 other) => EqualityComparer<T7>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case7 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T7>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T7>(Case);
        }

        public struct case8 : union, IEquatable<case8>, I<T8>
        {
            public static implicit operator case8(T8 x) => new case8(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case8; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map8(Case);

            public T8 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T8 Case;
            public case8(T8 x) => Case = x;

            public bool Equals(case8 other) => EqualityComparer<T8>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case8 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T8>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T8>(Case);
        }

        public struct case9 : union, IEquatable<case9>, I<T9>
        {
            public static implicit operator case9(T9 x) => new case9(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case9; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map9(Case);

            public T9 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T9 Case;
            public case9(T9 x) => Case = x;

            public bool Equals(case9 other) => EqualityComparer<T9>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case9 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T9>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T9>(Case);
        }

        public struct case10 : union, IEquatable<case10>, I<T10>
        {
            public static implicit operator case10(T10 x) => new case10(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case10; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map10(Case);

            public T10 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T10 Case;
            public case10(T10 x) => Case = x;

            public bool Equals(case10 other) => EqualityComparer<T10>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case10 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T10>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T10>(Case);
        }
    }

#pragma warning restore 1591

    /// <summary>Methods to work with immutable arrays and some sugar.</summary>
    public static class ArrayTools
    {
        private static class EmptyArray<T>
        {
            public static readonly T[] Value = new T[0];
        }

        /// <summary>Returns singleton empty array of provided type.</summary> 
        /// <typeparam name="T">Array item type.</typeparam> <returns>Empty array.</returns>
        public static T[] Empty<T>() => EmptyArray<T>.Value;

        /// <summary>Wraps item in array.</summary>
        public static T[] One<T>(this T one) => new[] { one };

        /// <summary>Returns true if array is null or have no items.</summary> <typeparam name="T">Type of array item.</typeparam>
        /// <param name="source">Source array to check.</param> <returns>True if null or has no items, false otherwise.</returns>
        public static bool IsNullOrEmpty<T>(this T[] source) => source == null || source.Length == 0;

        /// <summary>Returns empty array instead of null, or source array otherwise.</summary> <typeparam name="T">Type of array item.</typeparam>
        public static T[] EmptyIfNull<T>(this T[] source) => source ?? Empty<T>();

        /// Returns source enumerable if it is array, otherwise converts source to array or an empty array if null.
        public static T[] ToArrayOrSelf<T>(this IEnumerable<T> source) =>
            source == null ? Empty<T>() : (source as T[] ?? source.ToArray());

        /// Returns source enumerable if it is list, otherwise converts source to IList or an empty array if null.
        public static IList<T> ToListOrSelf<T>(this IEnumerable<T> source) =>
            source == null ? Empty<T>() : source as IList<T> ?? source.ToList();

        /// <summary>
        /// Array copy
        /// </summary>
        public static T[] Copy<T>(this T[] items)
        {
            if (items == null)
                return null;
            var copy = new T[items.Length];
            for (var i = 0; i < copy.Length; i++)
                copy[i] = items[i];
            return copy;
        }

        /// <summary>Returns new array consisting from all items from source array then all items from added array.
        /// If source is null or empty, then added array will be returned.
        /// If added is null or empty, then source will be returned.</summary>
        /// <typeparam name="T">Array item type.</typeparam>
        /// <param name="source">Array with leading items.</param>
        /// <param name="added">Array with following items.</param>
        /// <returns>New array with items of source and added arrays.</returns>
        public static T[] Append<T>(this T[] source, params T[] added)
        {
            if (added == null || added.Length == 0)
                return source;
            if (source == null || source.Length == 0)
                return added;

            var result = new T[source.Length + added.Length];
            Array.Copy(source, 0, result, 0, source.Length);
            if (added.Length == 1)
                result[source.Length] = added[0];
            else
                Array.Copy(added, 0, result, source.Length, added.Length);
            return result;
        }

        /// <summary>Performant concat of enumerables in case of arrays.
        /// But performance will degrade if you use Concat().Where().</summary>
        /// <typeparam name="T">Type of item.</typeparam>
        /// <param name="source">goes first.</param>
        /// <param name="other">appended to source.</param>
        /// <returns>empty array or concat of source and other.</returns>
        public static T[] Append<T>(this IEnumerable<T> source, IEnumerable<T> other) =>
            source.ToArrayOrSelf().Append(other.ToArrayOrSelf());

        /// <summary>Returns new array with <paramref name="value"/> appended, 
        /// or <paramref name="value"/> at <paramref name="index"/>, if specified.
        /// If source array could be null or empty, then single value item array will be created despite any index.</summary>
        /// <typeparam name="T">Array item type.</typeparam>
        /// <param name="source">Array to append value to.</param>
        /// <param name="value">Value to append.</param>
        /// <param name="index">(optional) Index of value to update.</param>
        /// <returns>New array with appended or updated value.</returns>
        public static T[] AppendOrUpdate<T>(this T[] source, T value, int index = -1)
        {
            if (source == null || source.Length == 0)
                return new[] { value };
            var sourceLength = source.Length;
            index = index < 0 ? sourceLength : index;
            var result = new T[index < sourceLength ? sourceLength : sourceLength + 1];
            Array.Copy(source, result, sourceLength);
            result[index] = value;
            return result;
        }

        /// <summary>Calls predicate on each item in <paramref name="source"/> array until predicate returns true,
        /// then method will return this item index, or if predicate returns false for each item, method will return -1.</summary>
        /// <typeparam name="T">Type of array items.</typeparam>
        /// <param name="source">Source array: if null or empty, then method will return -1.</param>
        /// <param name="predicate">Delegate to evaluate on each array item until delegate returns true.</param>
        /// <returns>Index of item for which predicate returns true, or -1 otherwise.</returns>
        public static int IndexOf<T>(this T[] source, Func<T, bool> predicate)
        {
            if (source is not null && source.Length != 0)
                for (var i = 0; i < source.Length; ++i)
                    if (predicate(source[i]))
                        return i;
            return -1;
        }

        /// Minimizes the allocations for closure in predicate lambda with the provided <paramref name="state"/>
        public static int IndexOf<T, S>(this T[] source, S state, Func<S, T, bool> predicate)
        {
            if (source is not null && source.Length != 0)
                for (var i = 0; i < source.Length; ++i)
                    if (predicate(state, source[i]))
                        return i;
            return -1;
        }

        /// <summary>Looks up for item in source array equal to provided value, and returns its index, or -1 if not found.</summary>
        /// <typeparam name="T">Type of array items.</typeparam>
        /// <param name="source">Source array: if null or empty, then method will return -1.</param>
        /// <param name="value">Value to look up.</param>
        /// <returns>Index of item equal to value, or -1 item is not found.</returns>
        public static int IndexOf<T>(this T[] source, T value)
        {
            if (source is not null && source.Length != 0)
                for (var i = 0; i < source.Length; ++i)
                {
                    var item = source[i];
                    if (Equals(item, value))
                        return i;
                }

            return -1;
        }

        /// <summary>Produces new array without item at specified <paramref name="index"/>. 
        /// Will return <paramref name="source"/> array if index is out of bounds, or source is null/empty.</summary>
        /// <typeparam name="T">Type of array item.</typeparam>
        /// <param name="source">Input array.</param> <param name="index">Index if item to remove.</param>
        /// <returns>New array with removed item at index, or input source array if index is not in array.</returns>
        public static T[] RemoveAt<T>(this T[] source, int index)
        {
            if (source == null || source.Length == 0 || index < 0 || index >= source.Length)
                return source;
            if (index == 0 && source.Length == 1)
                return new T[0];
            var result = new T[source.Length - 1];
            if (index != 0)
                Array.Copy(source, 0, result, 0, index);
            if (index != result.Length)
                Array.Copy(source, index + 1, result, index, result.Length - index);
            return result;
        }

        /// <summary>Looks for item in array using equality comparison, and returns new array with found item remove, or original array if not item found.</summary>
        /// <typeparam name="T">Type of array item.</typeparam>
        /// <param name="source">Input array.</param> <param name="value">Value to find and remove.</param>
        /// <returns>New array with value removed or original array if value is not found.</returns>
        public static T[] Remove<T>(this T[] source, T value) =>
            source.RemoveAt(source.IndexOf(value));

        /// <summary>Returns first item matching the <paramref name="predicate"/>, or default item value.</summary>
        /// <typeparam name="T">item type</typeparam>
        /// <param name="source">items collection to search</param>
        /// <param name="predicate">condition to evaluate for each item.</param>
        /// <returns>First item matching condition or default value.</returns>
        public static T FindFirst<T>(this T[] source, Func<T, bool> predicate)
        {
            if (source is not null && source.Length != 0)
                for (var i = 0; i < source.Length; ++i)
                {
                    var item = source[i];
                    if (predicate(item))
                        return item;
                }

            return default(T);
        }

        /// Version of FindFirst with the fixed state used by predicate to prevent allocations by predicate lambda closure
        public static T FindFirst<T, S>(this T[] source, S state, Func<S, T, bool> predicate)
        {
            if (source is not null && source.Length != 0)
                for (var i = 0; i < source.Length; ++i)
                {
                    var item = source[i];
                    if (predicate(state, item))
                        return item;
                }

            return default(T);
        }

        /// <summary>Returns first item matching the <paramref name="predicate"/>, or default item value.</summary>
        /// <typeparam name="T">item type</typeparam>
        /// <param name="source">items collection to search</param>
        /// <param name="predicate">condition to evaluate for each item.</param>
        /// <returns>First item matching condition or default value.</returns>
        public static T FindFirst<T>(this IEnumerable<T> source, Func<T, bool> predicate) =>
            source is T[] sourceArr ? sourceArr.FindFirst(predicate) : source.FirstOrDefault(predicate);

        /// <summary>Returns element if collection consist on single element, otherwise returns default value.
        /// It does not throw for collection with many elements</summary>
        public static T SingleOrDefaultIfMany<T>(this IEnumerable<T> source)
        {
            if (source is IList<T> list)
                return list.Count == 1 ? list[0] : default(T);

            if (source == null)
                return default(T);

            using (var e = source.GetEnumerator())
            {
                if (!e.MoveNext())
                    return default(T);
                var it = e.Current;
                return !e.MoveNext() ? it : default(T);
            }
        }

        /// <summary>Does <paramref name="action"/> for each item</summary>
        public static void ForEach<T>(this T[] source, Action<T> action)
        {
            if (!source.IsNullOrEmpty())
                for (var i = 0; i < source.Length; i++)
                    action(source[i]);
        }

        /// Appends source to results
        public static T[] AppendTo<T>(T[] source, int sourcePos, int count, T[] results = null)
        {
            if (results == null)
            {
                var newResults = new T[count];
                if (count == 1)
                    newResults[0] = source[sourcePos];
                else
                    for (int i = 0, j = sourcePos; i < count; ++i, ++j)
                        newResults[i] = source[j];
                return newResults;
            }

            var matchCount = results.Length;
            var appendedResults = new T[matchCount + count];
            if (matchCount == 1)
                appendedResults[0] = results[0];
            else
                Array.Copy(results, 0, appendedResults, 0, matchCount);

            if (count == 1)
                appendedResults[matchCount] = source[sourcePos];
            else
                Array.Copy(source, sourcePos, appendedResults, matchCount, count);

            return appendedResults;
        }

        private static R[] AppendTo<T, R>(T[] source, int sourcePos, int count, Func<T, R> map, R[] results = null)
        {
            if (results == null || results.Length == 0)
            {
                var newResults = new R[count];
                if (count == 1)
                    newResults[0] = map(source[sourcePos]);
                else
                    for (int i = 0, j = sourcePos; i < count; ++i, ++j)
                        newResults[i] = map(source[j]);
                return newResults;
            }

            var oldResultsCount = results.Length;
            var appendedResults = new R[oldResultsCount + count];
            if (oldResultsCount == 1)
                appendedResults[0] = results[0];
            else
                Array.Copy(results, 0, appendedResults, 0, oldResultsCount);

            if (count == 1)
                appendedResults[oldResultsCount] = map(source[sourcePos]);
            else
            {
                for (int i = oldResultsCount, j = sourcePos; i < appendedResults.Length; ++i, ++j)
                    appendedResults[i] = map(source[j]);
            }

            return appendedResults;
        }

        private static R[] AppendTo<T, S, R>(T[] source, S state, int sourcePos, int count, Func<S, T, R> map, R[] results = null)
        {
            if (results == null || results.Length == 0)
            {
                var newResults = new R[count];
                if (count == 1)
                    newResults[0] = map(state, source[sourcePos]);
                else
                    for (int i = 0, j = sourcePos; i < count; ++i, ++j)
                        newResults[i] = map(state, source[j]);
                return newResults;
            }

            var oldResultsCount = results.Length;
            var appendedResults = new R[oldResultsCount + count];
            if (oldResultsCount == 1)
                appendedResults[0] = results[0];
            else
                Array.Copy(results, 0, appendedResults, 0, oldResultsCount);

            if (count == 1)
                appendedResults[oldResultsCount] = map(state, source[sourcePos]);
            else
            {
                for (int i = oldResultsCount, j = sourcePos; i < appendedResults.Length; ++i, ++j)
                    appendedResults[i] = map(state, source[j]);
            }

            return appendedResults;
        }

        /// <summary>Where method similar to Enumerable.Where but more performant and non necessary allocating.
        /// It returns source array and does Not create new one if all items match the condition.</summary>
        /// <typeparam name="T">Type of source items.</typeparam>
        /// <param name="source">If null, the null will be returned.</param>
        /// <param name="condition">Condition to keep items.</param>
        /// <returns>New array if some items are filter out. Empty array if all items are filtered out. Original array otherwise.</returns>
        public static T[] Match<T>(this T[] source, Func<T, bool> condition)
        {
            if (source == null || source.Length == 0)
                return source;

            if (source.Length == 1)
                return condition(source[0]) ? source : Empty<T>();

            if (source.Length == 2)
            {
                var condition0 = condition(source[0]);
                var condition1 = condition(source[1]);
                return condition0 && condition1 ? new[] { source[0], source[1] }
                    : condition0 ? new[] { source[0] }
                    : condition1 ? new[] { source[1] }
                    : Empty<T>();
            }

            var matchStart = 0;
            T[] matches = null;
            var matchFound = false;
            var i = 0;
            for (; i < source.Length; ++i)
                if (!(matchFound = condition(source[i])))
                {
                    // for accumulated matched items
                    if (i != 0 && i > matchStart)
                        matches = AppendTo(source, matchStart, i - matchStart, matches);
                    matchStart = i + 1; // guess the next match start will be after the non-matched item
                }

            // when last match was found but not all items are matched (hence matchStart != 0)
            if (matchFound && matchStart != 0)
                return AppendTo(source, matchStart, i - matchStart, matches);

            return matches ?? (matchStart != 0 ? Empty<T>() : source);
        }

        /// Match with the additional state to use in <paramref name="condition"/> to minimize the allocations in <paramref name="condition"/> lambda closure 
        public static T[] Match<T, S>(this T[] source, S state, Func<S, T, bool> condition)
        {
            if (source == null || source.Length == 0)
                return source;

            if (source.Length == 1)
                return condition(state, source[0]) ? source : Empty<T>();

            if (source.Length == 2)
            {
                var condition0 = condition(state, source[0]);
                var condition1 = condition(state, source[1]);
                return condition0 && condition1 ? new[] { source[0], source[1] }
                    : condition0 ? new[] { source[0] }
                    : condition1 ? new[] { source[1] }
                    : Empty<T>();
            }

            var matchStart = 0;
            T[] matches = null;
            var matchFound = false;
            var i = 0;
            for (; i < source.Length; ++i)
                if (!(matchFound = condition(state, source[i])))
                {
                    // for accumulated matched items
                    if (i != 0 && i > matchStart)
                        matches = AppendTo(source, matchStart, i - matchStart, matches);
                    matchStart = i + 1; // guess the next match start will be after the non-matched item
                }

            // when last match was found but not all items are matched (hence matchStart != 0)
            if (matchFound && matchStart != 0)
                return AppendTo(source, matchStart, i - matchStart, matches);

            return matches ?? (matchStart != 0 ? Empty<T>() : source);
        }

        /// <summary>Where method similar to Enumerable.Where but more performant and non necessary allocating.
        /// It returns source array and does Not create new one if all items match the condition.</summary>
        /// <typeparam name="T">Type of source items.</typeparam> <typeparam name="R">Type of result items.</typeparam>
        /// <param name="source">If null, the null will be returned.</param>
        /// <param name="condition">Condition to keep items.</param> <param name="map">Converter from source to result item.</param>
        /// <returns>New array of result items.</returns>
        public static R[] Match<T, R>(this T[] source, Func<T, bool> condition, Func<T, R> map)
        {
            if (source == null)
                return null;

            if (source.Length == 0)
                return Empty<R>();

            if (source.Length == 1)
            {
                var item = source[0];
                return condition(item) ? new[] { map(item) } : Empty<R>();
            }

            if (source.Length == 2)
            {
                var condition0 = condition(source[0]);
                var condition1 = condition(source[1]);
                return condition0 && condition1 ? new[] { map(source[0]), map(source[1]) }
                    : condition0 ? new[] { map(source[0]) }
                    : condition1 ? new[] { map(source[1]) }
                    : Empty<R>();
            }

            var matchStart = 0;
            R[] matches = null;
            var matchFound = false;

            var i = 0;
            for (; i < source.Length; ++i)
                if (!(matchFound = condition(source[i])))
                {
                    // for accumulated matched items
                    if (i != 0 && i > matchStart)
                        matches = AppendTo(source, matchStart, i - matchStart, map, matches);
                    matchStart = i + 1; // guess the next match start will be after the non-matched item
                }

            // when last match was found but not all items are matched (hence matchStart != 0)
            if (matchFound && matchStart != 0)
                return AppendTo(source, matchStart, i - matchStart, map, matches);

            return matches ?? (matchStart == 0 ? AppendTo(source, 0, source.Length, map) : Empty<R>());
        }

        /// Match with the additional state to use in <paramref name="condition"/> and <paramref name="map"/> to minimize the allocations in <paramref name="condition"/> lambda closure 
        public static R[] Match<T, S, R>(this T[] source, S state, Func<S, T, bool> condition, Func<S, T, R> map)
        {
            if (source == null)
                return null;

            if (source.Length == 0)
                return Empty<R>();

            if (source.Length == 1)
            {
                var item = source[0];
                return condition(state, item) ? new[] { map(state, item) } : Empty<R>();
            }

            if (source.Length == 2)
            {
                var condition0 = condition(state, source[0]);
                var condition1 = condition(state, source[1]);
                return condition0 && condition1 ? new[] { map(state, source[0]), map(state, source[1]) }
                    : condition0 ? new[] { map(state, source[0]) }
                    : condition1 ? new[] { map(state, source[1]) }
                    : Empty<R>();
            }

            var matchStart = 0;
            R[] matches = null;
            var matchFound = false;

            var i = 0;
            for (; i < source.Length; ++i)
                if (!(matchFound = condition(state, source[i])))
                {
                    // for accumulated matched items
                    if (i != 0 && i > matchStart)
                        matches = AppendTo(source, state, matchStart, i - matchStart, map, matches);
                    matchStart = i + 1; // guess the next match start will be after the non-matched item
                }

            // when last match was found but not all items are matched (hence matchStart != 0)
            if (matchFound && matchStart != 0)
                return AppendTo(source, state, matchStart, i - matchStart, map, matches);

            return matches ?? (matchStart == 0 ? AppendTo(source, state, 0, source.Length, map) : Empty<R>());
        }

        /// <summary>Maps all items from source to result array.</summary>
        /// <typeparam name="T">Source item type</typeparam> <typeparam name="R">Result item type</typeparam>
        /// <param name="source">Source items</param> <param name="map">Function to convert item from source to result.</param>
        /// <returns>Converted items</returns>
        public static R[] Map<T, R>(this T[] source, Func<T, R> map)
        {
            if (source == null)
                return null;

            var sourceCount = source.Length;
            if (sourceCount == 0)
                return Empty<R>();

            if (sourceCount == 1)
                return new[] { map(source[0]) };

            if (sourceCount == 2)
                return new[] { map(source[0]), map(source[1]) };

            var results = new R[sourceCount];
            for (var i = 0; i < source.Length; i++)
                results[i] = map(source[i]);
            return results;
        }

        /// Map with additional state to use in <paramref name="map"/> to minimize allocations in <paramref name="map"/> lambda closure 
        public static R[] Map<T, S, R>(this T[] source, S state, Func<S, T, R> map)
        {
            if (source == null)
                return null;

            var sourceCount = source.Length;
            if (sourceCount == 0)
                return Empty<R>();

            if (sourceCount == 1)
                return new[] { map(state, source[0]) };

            if (sourceCount == 2)
                return new[] { map(state, source[0]), map(state, source[1]) };

            var results = new R[sourceCount];
            for (var i = 0; i < source.Length; i++)
                results[i] = map(state, source[i]);
            return results;
        }

        /// <summary>Maps all items from source to result collection. 
        /// If possible uses fast array Map otherwise Enumerable.Select.</summary>
        /// <typeparam name="T">Source item type</typeparam> <typeparam name="R">Result item type</typeparam>
        /// <param name="source">Source items</param> <param name="map">Function to convert item from source to result.</param>
        /// <returns>Converted items</returns>
        public static IEnumerable<R> Map<T, R>(this IEnumerable<T> source, Func<T, R> map) =>
            source is T[] arr ? arr.Map(map) : source?.Select(map);

        /// <summary>If <paramref name="source"/> is array uses more effective Match for array, otherwise just calls Where</summary>
        /// <typeparam name="T">Type of source items.</typeparam>
        /// <param name="source">If null, the null will be returned.</param>
        /// <param name="condition">Condition to keep items.</param>
        /// <returns>Result items, may be an array.</returns>
        public static IEnumerable<T> Match<T>(this IEnumerable<T> source, Func<T, bool> condition) =>
            source is T[] arr ? arr.Match(condition) : source?.Where(condition);

        /// <summary>If <paramref name="source"/> is array uses more effective Match for array,
        /// otherwise just calls Where, Select</summary>
        /// <typeparam name="T">Type of source items.</typeparam> <typeparam name="R">Type of result items.</typeparam>
        /// <param name="source">If null, the null will be returned.</param>
        /// <param name="condition">Condition to keep items.</param>  <param name="map">Converter from source to result item.</param>
        /// <returns>Result items, may be an array.</returns>
        public static IEnumerable<R> Match<T, R>(this IEnumerable<T> source, Func<T, bool> condition, Func<T, R> map) =>
            source is T[] arr ? arr.Match(condition, map) : source?.Where(condition).Select(map);
    }

    /// <summary>Wrapper that provides optimistic-concurrency Swap operation implemented using <see cref="Ref.Swap{T}"/>.</summary>
    /// <typeparam name="T">Type of object to wrap.</typeparam>
    public sealed class Ref<T> where T : class
    {
        /// <summary>Gets the wrapped value.</summary>
        public T Value => _value;
        private T _value;

        /// <summary>Creates ref to object, optionally with initial value provided.</summary>
        /// <param name="initialValue">(optional) Initial value.</param>
        public Ref(T initialValue = default) => _value = initialValue;

        /// <summary>Exchanges currently hold object with <paramref name="getNewValue"/> - see <see cref="Ref.Swap{T}"/> for details.</summary>
        /// <param name="getNewValue">Delegate to produce new object value from current one passed as parameter.</param>
        /// <returns>Returns old object value the same way as <see cref="Interlocked.Exchange(ref int,int)"/></returns>
        /// <remarks>Important: <paramref name="getNewValue"/> May be called multiple times to retry update with value concurrently changed by other code.</remarks>
        public T Swap(Func<T, T> getNewValue) =>
            Ref.Swap(ref _value, getNewValue);

        /// Option without allocation for capturing `a` in closure of `getNewValue`
        public T Swap<A>(A a, Func<T, A, T> getNewValue) => Ref.Swap(ref _value, a, getNewValue);

        /// Option without allocation for capturing `a` and `b` in closure of `getNewValue`
        public T Swap<A, B>(A a, B b, Func<T, A, B, T> getNewValue) => Ref.Swap(ref _value, a, b, getNewValue);

        /// <summary>Just sets new value ignoring any intermingled changes and returns the original value</summary>
        /// <param name="newValue"></param> <returns>old value</returns>
        public T Swap(T newValue) => Interlocked.Exchange(ref _value, newValue);

        /// <summary>Directly sets the value and returns the new value</summary>
        public T SetNonAtomic(T newValue) => _value = newValue;

        /// <summary>Compares current Referred value with <paramref name="currentValue"/> and if equal replaces current with <paramref name="newValue"/></summary>
        /// <param name="currentValue"></param> <param name="newValue"></param>
        /// <returns>True if current value was replaced with new value, and false if current value is outdated (already changed by other party).</returns>
        /// <example><c>[!CDATA[
        /// var value = SomeRef.Value;
        /// if (!SomeRef.TrySwapIfStillCurrent(value, Update(value))
        ///     SomeRef.Swap(v => Update(v)); // fallback to normal Swap with delegate allocation
        /// ]]</c></example>
        public bool TrySwapIfStillCurrent(T currentValue, T newValue) =>
            Interlocked.CompareExchange(ref _value, newValue, currentValue) == currentValue;
    }

    /// <summary>Provides optimistic-concurrency consistent <see cref="Swap{T}"/> operation.</summary>
    public static class Ref
    {
        /// The default max retry count - can be overriden by `Swap` optional parameter 
        public const int RETRY_COUNT_UNTIL_THROW = 50;

        /// <summary>Factory for <see cref="Ref{T}"/> with type of value inference.</summary>
        /// <typeparam name="T">Type of value to wrap.</typeparam>
        /// <param name="value">Initial value to wrap.</param>
        /// <returns>New ref.</returns>
        public static Ref<T> Of<T>(T value) where T : class => new Ref<T>(value);

        /// <summary>Creates new ref to the value of original ref.</summary> <typeparam name="T">Ref value type.</typeparam>
        /// <param name="original">Original ref.</param> <returns>New ref to original value.</returns>
        public static Ref<T> NewRef<T>(this Ref<T> original) where T : class => Of(original.Value);

        /// <summary>First, it evaluates new value using <paramref name="getNewValue"/> function. 
        /// Second, it checks that original value is not changed. 
        /// If it is changed it will retry first step, otherwise it assigns new value and returns original (the one used for <paramref name="getNewValue"/>).</summary>
        /// <typeparam name="T">Type of value to swap.</typeparam>
        /// <param name="value">Reference to change to new value</param>
        /// <param name="getNewValue">Delegate to get value from old one.</param>
        /// <param name="retryCountUntilThrow">(optional)</param>
        /// <returns>Old/original value. By analogy with <see cref="Interlocked.Exchange(ref int,int)"/>.</returns>
        /// <remarks>Important: <paramref name="getNewValue"/> May be called multiple times to retry update with value concurrently changed by other code.</remarks>
        [MethodImpl((MethodImplOptions)256)]
        public static T Swap<T>(ref T value, Func<T, T> getNewValue,
            int retryCountUntilThrow = RETRY_COUNT_UNTIL_THROW)
            where T : class
        {
#if SUPPORTS_SPIN_WAIT
            var spinWait = new SpinWait();
#endif
            var retryCount = 0;
            while (true)
            {
                var oldValue = value;
                var newValue = getNewValue(oldValue);
                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)
                    return oldValue;

                if (++retryCount > retryCountUntilThrow)
                    ThrowRetryCountExceeded(retryCountUntilThrow);
#if SUPPORTS_SPIN_WAIT
                spinWait.SpinOnce();
#endif
            }
        }

        private static void ThrowRetryCountExceeded(int retryCountExceeded) =>
            throw new InvalidOperationException(
                $"Ref retried to Update for {retryCountExceeded} times But there is always someone else intervened.");

        /// <summary>
        /// Option without allocation for capturing `a` in closure of `getNewValue`
        /// </summary>
        [MethodImpl((MethodImplOptions)256)]
        public static T Swap<T, A>(ref T value, A a, Func<T, A, T> getNewValue,
            int retryCountUntilThrow = RETRY_COUNT_UNTIL_THROW)
            where T : class
        {
#if SUPPORTS_SPIN_WAIT
            var spinWait = new SpinWait();
#endif
            var retryCount = 0;
            while (true)
            {
                var oldValue = value;
                var newValue = getNewValue(oldValue, a);
                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)
                    return oldValue;
                if (++retryCount > retryCountUntilThrow)
                    ThrowRetryCountExceeded(retryCountUntilThrow);
#if SUPPORTS_SPIN_WAIT
                spinWait.SpinOnce();
#endif
            }
        }

        /// Option without allocation for capturing `a` and `b` in closure of `getNewValue`
        [MethodImpl((MethodImplOptions)256)]
        public static T Swap<T, A, B>(ref T value, A a, B b, Func<T, A, B, T> getNewValue,
            int retryCountUntilThrow = RETRY_COUNT_UNTIL_THROW)
            where T : class
        {
#if SUPPORTS_SPIN_WAIT
            var spinWait = new SpinWait();
#endif
            var retryCount = 0;
            while (true)
            {
                var oldValue = value;
                var newValue = getNewValue(oldValue, a, b);
                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)
                    return oldValue;

                if (++retryCount > retryCountUntilThrow)
                    ThrowRetryCountExceeded(retryCountUntilThrow);

#if SUPPORTS_SPIN_WAIT
                spinWait.SpinOnce();
#endif
            }
        }

        /// Option without allocation for capturing `a`, `b`, `c` in closure of `getNewValue`
        [MethodImpl((MethodImplOptions)256)]
        public static T Swap<T, A, B, C>(ref T value, A a, B b, C c, Func<T, A, B, C, T> getNewValue,
            int retryCountUntilThrow = RETRY_COUNT_UNTIL_THROW)
            where T : class
        {
#if SUPPORTS_SPIN_WAIT
            var spinWait = new SpinWait();
#endif
            var retryCount = 0;
            while (true)
            {
                var oldValue = value;
                var newValue = getNewValue(oldValue, a, b, c);
                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)
                    return oldValue;

                if (++retryCount > retryCountUntilThrow)
                    ThrowRetryCountExceeded(retryCountUntilThrow);

#if SUPPORTS_SPIN_WAIT
                spinWait.SpinOnce();
#endif
            }
        }

        // todo: Func of 5 args is not available on all plats
        //        /// Option without allocation for capturing `a`, `b`, `c`, `d` in closure of `getNewValue`
        //        [MethodImpl((MethodImplOptions)256)]
        //        public static T Swap<T, A, B, C, D>(ref T value, A a, B b, C c, D d, Func<T, A, B, C, D, T> getNewValue,
        //            int retryCountUntilThrow = RETRY_COUNT_UNTIL_THROW)
        //            where T : class
        //        {
        //#if SUPPORTS_SPIN_WAIT
        //            var spinWait = new SpinWait();
        //#endif
        //            var retryCount = 0;
        //            while (true)
        //            {
        //                var oldValue = value;
        //                var newValue = getNewValue(oldValue, a, b, c, d);
        //                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)
        //                    return oldValue;

        //                if (++retryCount > retryCountUntilThrow)
        //                    ThrowRetryCountExceeded(retryCountUntilThrow);

        //#if SUPPORTS_SPIN_WAIT
        //                spinWait.SpinOnce();
        //#endif
        //            }
        //        }
    }

    /// <summary>Printable thing via provided printer </summary>
    public interface IPrintable
    {
        /// <summary>Print to the provided string builder via the provided printer.</summary>
        StringBuilder Print(StringBuilder s, Func<StringBuilder, object, StringBuilder> printer);
    }

    /// <summary>Produces good enough hash codes for the fields</summary>
    public static class Hasher
    {
        /// <summary>Combines hashes of two fields</summary>
        public static int Combine<T1, T2>(T1 a, T2 b) =>
            Combine(a?.GetHashCode() ?? 0, b?.GetHashCode() ?? 0);

        /// <summary>Inspired by System.Tuple.CombineHashCodes</summary>
        public static int Combine(int h1, int h2)
        {
            if (h1 == 0) return h2;
            unchecked
            {
                return (h1 << 5) + h1 ^ h2;
            }
        }
    }

    /// Simple unbounded object pool
    public sealed class StackPool<T> where T : class
    {
        /// Give me an object
        public T RentOrDefault() =>
            Interlocked.Exchange(ref _s, _s?.Tail)?.Head;

        /// Give it back
        public void Return(T x) =>
            Interlocked.Exchange(ref _s, new Stack(x, _s));

        private Stack _s;

        private sealed class Stack
        {
            public readonly T Head;
            public readonly Stack Tail;
            public Stack(T h, Stack t)
            {
                Head = h;
                Tail = t;
            }
        }
    }

    /// <summary>Immutable Key-Value pair. It is reference type (could be check for null), 
    /// which is different from System value type <see cref="KeyValuePair{TKey,TValue}"/>.
    /// In addition provides <see cref="Equals"/> and <see cref="GetHashCode"/> implementations.</summary>
    /// <typeparam name="K">Type of Key.</typeparam><typeparam name="V">Type of Value.</typeparam>
    public class KV<K, V> : IPrintable
    {
        /// <summary>Key.</summary>
        public readonly K Key;

        /// <summary>Value.</summary>
        public readonly V Value;

        /// <summary>Creates Key-Value object by providing key and value. Does Not check either one for null.</summary>
        /// <param name="key">key.</param><param name="value">value.</param>
        public KV(K key, V value)
        {
            Key = key;
            Value = value;
        }

        /// <inheritdoc />
        public StringBuilder Print(StringBuilder s, Func<StringBuilder, object, StringBuilder> printer) =>
            s.Append("(").To(b => Key == null ? b : printer(b, Key))
                .Append(", ").To(b => Value == null ? b : printer(b, Value))
                .Append(')');

        /// <summary>Creates nice string view.</summary><returns>String representation.</returns>
        public override string ToString() =>
            Print(new StringBuilder(), (s, x) => s.Append(x)).ToString();

        /// <summary>Returns true if both key and value are equal to corresponding key-value of other object.</summary>
        public override bool Equals(object obj)
        {
            var other = obj as KV<K, V>;
            return other is not null
                   && (ReferenceEquals(other.Key, Key) || Equals(other.Key, Key))
                   && (ReferenceEquals(other.Value, Value) || Equals(other.Value, Value));
        }

        /// <summary>Combines key and value hash code</summary>
        public override int GetHashCode() => Hasher.Combine(Key, Value);
    }

    /// <summary>Helpers for <see cref="KV{K,V}"/>.</summary>
    public static class KV
    {
        /// <summary>Creates the key value pair.</summary>
        public static KV<K, V> Of<K, V>(K key, V value) => new KV<K, V>(key, value);

        /// <summary>Creates the pair with the new value</summary>
        public static KV<K, V> WithValue<K, V>(this KV<K, V> kv, V value) => new KV<K, V>(kv.Key, value);
    }

    /// Simple helper for creation of the pair of two parts.
    public static class KeyValuePair
    {
        /// Pairs key with value.
        public static KeyValuePair<K, V> Pair<K, V>(this K key, V value) => new KeyValuePair<K, V>(key, value);
    }

    /// <summary>Helper structure which allows to distinguish null value from the default value for optional parameter.</summary>
    public struct Opt<T>
    {
        /// <summary>Allows to transparently convert parameter argument to opt structure.</summary>
        public static implicit operator Opt<T>(T value) => new Opt<T>(value);

        /// <summary>Argument value.</summary>
        public readonly T Value;

        /// <summary>Indicates that value is provided.</summary>
        public readonly bool HasValue;

        /// <summary>Wraps passed value in structure. Sets the flag that value is present.</summary>
        public Opt(T value)
        {
            HasValue = true;
            Value = value;
        }

        /// <summary>Helper to get value or default value if value is not present.</summary>
        public T OrDefault(T defaultValue = default) => HasValue ? Value : defaultValue;
    }

    /// <summary>Ever growing list</summary>
    public struct GrowingList<T>
    {
        /// <summary>Default initial capacity </summary>
        public const int DefaultInitialCapacity = 2;

        /// The items array
        public T[] Items;

        /// The count
        public int Count;

        /// Constructs the thing 
        public GrowingList(T[] items, int count = 0)
        {
            Items = items;
            Count = count;
        }

        /// Push the new slot and return the ref to it
        public ref T PushSlot()
        {
            if (Items == null)
                Items = new T[DefaultInitialCapacity];
            else if (Count >= Items.Length)
                Items = Expand(Items);
            return ref Items[Count++];
        }

        /// Adds the new item possibly extending the item collection
        public void PushSlot(T item)
        {
            if (Items == null)
                Items = new T[DefaultInitialCapacity];
            else if (Count >= Items.Length)
                Items = Expand(Items);
            Items[Count++] = item;
        }

        /// Pops the item - just moving the counter back
        public void Pop() => --Count;

        /// Expands the items starting with 2
        private static T[] Expand(T[] items)
        {
            var count = items.Length;
            var newItems = new T[count << 1]; // count x 2
            Array.Copy(items, 0, newItems, 0, count);
            return newItems;
        }

        /// <inheritdoc />
        public override string ToString() =>
            $"Count {Count} of {(Count == 0 || Items == null || Items.Length == 0 ? "empty" : "first (" + Items[0] + ") and last (" + Items[Count - 1] + ")")}";
    }

    /// <summary>Immutable list - simplest linked list with the Head and the Tail.</summary>
    public sealed class ImList<T>
    {
        /// <summary>Empty list to Push to.</summary>
        public static readonly ImList<T> Empty = new ImList<T>();

        /// <summary>True for empty list.</summary>
        public bool IsEmpty => Tail == null;

        /// <summary>First value in a list.</summary>
        public readonly T Head;

        /// <summary>The rest of values or Empty if list has a single value.</summary>
        public readonly ImList<T> Tail;

        /// <summary>Prepends new value and returns new list.</summary>
        public ImList<T> Push(T head) => new ImList<T>(head, this);

        /// <summary>Enumerates the list.</summary>
        public IEnumerable<T> Enumerate()
        {
            if (IsEmpty)
                yield break;
            for (var list = this; !list.IsEmpty; list = list.Tail)
                yield return list.Head;
        }

        /// <summary>String representation for debugging purposes</summary>
        public override string ToString() => IsEmpty
            ? "[]" : Tail.IsEmpty
            ? "[" + Head + "]" : Tail.Tail.IsEmpty
            ? "[" + Head + "," + Tail.Head + "]" : Tail.Tail.Tail.IsEmpty
            ? "[" + Head + "," + Tail.Head + "," + Tail.Tail.Head + "]"
            : "[" + Head + "," + Tail.Head + "," + Tail.Tail.Head + ", ...]";

        private ImList() { }

        private ImList(T head, ImList<T> tail)
        {
            Head = head;
            Tail = tail;
        }
    }

    /// <summary>Extension methods providing basic operations on a list.</summary>
    public static class ImList
    {
        /// Split list into (Head, Tail, IsEmpty) tuple
        public static void Deconstruct<T>(this ImList<T> list, out T head, out ImList<T> tail, out bool isEmpty)
        {
            head = list.Head;
            tail = list.Tail;
            isEmpty = list.IsEmpty;
        }

        /// <summary>
        /// Constructs the reversed list from the parameter array of items
        /// </summary>
        public static ImList<T> List<T>(params T[] items)
        {
            var l = ImList<T>.Empty;
            if (items is not null)
                for (var i = items.Length - 1; i >= 0; --i)
                    l = l.Push(items[i]);
            return l;
        }

        /// <summary>
        /// Constructs the list as the reversed input list
        /// </summary>
        public static ImList<T> ToImList<T>(this IList<T> source)
        {
            var l = ImList<T>.Empty;
            if (source is not null)
                for (var i = source.Count - 1; i >= 0; --i)
                    l = l.Push(source[i]);
            return l;
        }

        /// <summary>
        /// Constructs the list as the reversed enumerable
        /// </summary>
        public static ImList<T> ToImList<T>(this IEnumerable<T> source)
        {
            if (source is IList<T> list)
                return list.ToImList();
            var l = ImList<T>.Empty;

            if (source is not null)
                foreach (var item in source)
                    l = l.Push(item);
            return l.Reverse();
        }

        /// <summary>Constructs list of one element</summary>
        public static ImList<T> List<T>(this T head) => ImList<T>.Empty.Push(head);

        /// <summary>Constructs list from head and tail</summary>
        public static ImList<T> List<T>(this T head, ImList<T> tail) => tail.Push(head);

        /// <summary>Apples some effect action to each element</summary>
        public static void ForEach<T>(this ImList<T> list, Action<T> effect)
        {
            for (; !list.IsEmpty; list = list.Tail)
                effect(list.Head);
        }

        /// <summary>Fold list to a single value. The respective name for it in LINQ is Aggregate</summary>
        public static S Fold<T, S>(this ImList<T> list, S state, Func<T, S, S> reduce)
        {
            if (list.IsEmpty)
                return state;
            var result = state;
            for (; !list.IsEmpty; list = list.Tail)
                result = reduce(list.Head, result);
            return result;
        }

        /// <summary>Fold list to a single value with index of item. The respective name for it in LINQ is Aggregate.</summary>
        public static S Fold<T, S>(this ImList<T> list, S state, Func<T, int, S, S> reduce)
        {
            if (list.IsEmpty)
                return state;
            var result = state;
            for (var i = 0; !list.IsEmpty; list = list.Tail, ++i)
                result = reduce(list.Head, i, result);
            return result;
        }

        /// <summary>Returns new list in reverse order.</summary>
        public static ImList<T> Reverse<T>(this ImList<T> list)
        {
            if (list.IsEmpty || list.Tail.IsEmpty)
                return list;
            var reversed = ImList<T>.Empty;
            for (; !list.IsEmpty; list = list.Tail)
                reversed = reversed.Push(list.Head);
            return reversed;
        }

        /// <summary>Maps the items from the first list to the result list.</summary>
        public static ImList<R> Map<T, R>(this ImList<T> list, Func<T, R> map) =>
            list.Fold(ImList<R>.Empty, (x, r) => List(map(x), r)).Reverse();

        /// <summary>Maps with index</summary>
        public static ImList<R> Map<T, R>(this ImList<T> list, Func<T, int, R> map) =>
            list.Fold(ImList<R>.Empty, (x, i, r) => List(map(x, i), r)).Reverse();

        /// <summary>Copies list to array.</summary>
        public static T[] ToArray<T>(this ImList<T> source) =>
            source.IsEmpty ? ArrayTools.Empty<T>()
            : source.Tail.IsEmpty ? new[] { source.Head } : source.Enumerate().ToArray();
    }

    /// Zipper is an immutable persistent data structure, to represent collection with single focused (selected, active) element.
    /// Consist of REVERSED `Left` immutable list, `Focus` element, and the `Right` immutable list. That's why a Zipper name,
    /// where left and right part are joined / zipped in focus item.
    public sealed class ImZipper<T>
    {
        /// Empty singleton instance to start building your zipper
        public static readonly ImZipper<T> Empty = new ImZipper<T>();

        /// True is zipper does not contain items
        public bool IsEmpty => Count == 0;

        /// Index of Focus item, from `0` to `Count-1`
        public readonly int Index;

        /// Number of items
        public readonly int Count;

        /// Left REVERSED list, so the Head of the list is just prior the Focus item 
        public readonly ImList<T> Left;

        /// Right list, where Head is just after the Focus item
        public readonly ImList<T> Right;

        /// Single focus item
        public readonly T Focus;

        /// <inheritdoc />
        public override string ToString() =>
            IsEmpty ? "[||]" : Count + ":" + Left.Reverse() + "|" + Index + ":" + Focus + "|" + Right;

        /// Sets a new focus and pushes the old focus to the Left list. 
        public ImZipper<T> Append(T focus) => PushLeft(focus);

        /// Sets a new focus and pushes the old focus to the Left list.
        public ImZipper<T> PushLeft(T focus) =>
        IsEmpty ? new ImZipper<T>(ImList<T>.Empty, focus, 0, ImList<T>.Empty, 1)
                : new ImZipper<T>(Left.Push(Focus), focus, Index + 1, Right, Count + 1);

        /// Sets a new focus and pushes the old focus to the right list. 
        public ImZipper<T> Insert(T focus) => PushRight(focus);

        /// Sets a new focus and pushes the old focus to the right list. 
        public ImZipper<T> PushRight(T focus) =>
            IsEmpty ? new ImZipper<T>(ImList<T>.Empty, focus, 0, ImList<T>.Empty, 1)
                : new ImZipper<T>(Left, focus, Index, Right.Push(Focus), Count + 1);

        /// Removes a focus, filling the hole with the item from the left list, or from the right if the left is empty
        public ImZipper<T> PopLeft() =>
            IsEmpty ? this
            : Left.IsEmpty && Right.IsEmpty ? Empty
            : !Left.IsEmpty ? new ImZipper<T>(Left.Tail, Left.Head, Index - 1, Right, Count - 1)
            : new ImZipper<T>(Left, Right.Head, Index, Right.Tail, Count - 1);

        /// Removes a focus, filling the hole with the item from the right list, or from the left if the right is empty
        public ImZipper<T> PopRight() =>
            IsEmpty ? this
            : Left.IsEmpty && Right.IsEmpty ? Empty
            : !Right.IsEmpty ? new ImZipper<T>(Left, Right.Head, Index, Right.Tail, Count - 1)
            : new ImZipper<T>(Left.Tail, Left.Head, Index - 1, Right, Count - 1);

        /// Shifts focus one element to the left (decrementing its Index).
        public ImZipper<T> ShiftLeft() =>
            IsEmpty || Left.IsEmpty ? this
            : new ImZipper<T>(Left.Tail, Left.Head, Index - 1, Right.Push(Focus), Count);

        /// Shifts focus one element to the right (incrementing its Index).
        public ImZipper<T> ShiftRight() =>
            IsEmpty || Right.IsEmpty ? this
            : new ImZipper<T>(Left.Push(Focus), Right.Head, Index + 1, Right.Tail, Count);

        /// Sets a new focus and returns a new zipper with the left and right lists unchanged
        public ImZipper<T> WithFocus(T focus) =>
            IsEmpty ? this : new ImZipper<T>(Left, focus, Index, Right, Count);

        /// Maps over the zipper items producing a new zipper
        public ImZipper<R> Map<R>(Func<T, R> map) =>
            IsEmpty ? ImZipper<R>.Empty
                : new ImZipper<R>(Left.Reverse().Fold(ImList<R>.Empty, (x, r) => r.Push(map(x))),
                    map(Focus), Index, Right.Map(map), Count);

        /// Maps over the zipper items with item index, producing a new zipper
        public ImZipper<R> Map<R>(Func<T, int, R> map) =>
            IsEmpty ? ImZipper<R>.Empty
                : new ImZipper<R>(
                    Left.Reverse().Fold(ImList<R>.Empty, (x, i, r) => r.Push(map(x, i))),
                    map(Focus, Index), Index, Right.Map((x, i) => map(x, Index + 1 + i)), Count);

        private ImZipper() => Index = -1;

        private ImZipper(ImList<T> left, T focus, int index, ImList<T> right, int count)
        {
            Left = left;
            Focus = focus;
            Index = index;
            Right = right;
            Count = count;
        }
    }

    /// Other ImZipper methods
    public static class ImZipper
    {
        /// Appends array items to zipper
        public static ImZipper<T> Zip<T>(params T[] items)
        {
            if (items.IsNullOrEmpty())
                return ImZipper<T>.Empty;
            var z = ImZipper<T>.Empty;
            for (var i = 0; i < items.Length; ++i)
                z = z.PushLeft(items[i]);
            return z;
        }

        /// Converts to array.
        public static T[] ToArray<T>(this ImZipper<T> z)
        {
            if (z.IsEmpty)
                return ArrayTools.Empty<T>();
            var a = new T[z.Count];
            z.Fold(a, (x, i, xs) =>
            {
                xs[i] = x;
                return xs;
            });
            return a;
        }

        /// Shifts focus to a specified index, e.g. a random access
        public static ImZipper<T> ShiftTo<T>(this ImZipper<T> z, int i)
        {
            if (i < 0 || i >= z.Count || i == z.Index)
                return z;
            while (i < z.Index)
                z = z.ShiftLeft();
            while (i > z.Index)
                z = z.ShiftRight();
            return z;
        }

        /// Updates a focus element if it is present, otherwise does nothing.
        /// If the focus item is the equal one, then returns the same zipper back.
        public static ImZipper<T> Update<T>(this ImZipper<T> z, Func<T, T> update)
        {
            if (z.IsEmpty)
                return z;
            var result = update(z.Focus);
            if (ReferenceEquals(z.Focus, result) || result is not null && result.Equals(z.Focus))
                return z;
            return z.WithFocus(result);
        }

        /// Update the item at random index, by shifting and updating it
        public static ImZipper<T> UpdateAt<T>(this ImZipper<T> z, int i, Func<T, T> update) =>
            i < 0 || i >= z.Count ? z : z.ShiftTo(i).Update(update);

        /// Update the item at random index, by shifting and updating it
        public static ImZipper<T> RemoveAt<T>(this ImZipper<T> z, int i) =>
            i < 0 || i >= z.Count ? z : z.ShiftTo(i).PopLeft();

        /// Folds zipper to a single value
        public static S Fold<T, S>(this ImZipper<T> z, S state, Func<T, S, S> reduce) =>
            z.IsEmpty ? state :
            z.Right.Fold(reduce(z.Focus, z.Left.Reverse().Fold(state, reduce)), reduce);

        /// Folds zipper to a single value by using an item index
        public static S Fold<T, S>(this ImZipper<T> z, S state, Func<T, int, S, S> reduce)
        {
            if (z.IsEmpty)
                return state;
            var focusIndex = z.Index;
            var reducedLeft = z.Left.Reverse().Fold(state, reduce);
            return z.Right.Fold(reduce(z.Focus, focusIndex, reducedLeft),
                (x, i, r) => reduce(x, focusIndex + i + 1, r));
        }

        /// <summary>Apply some effect action on each element</summary>
        public static void ForEach<T>(this ImZipper<T> z, Action<T> effect)
        {
            if (!z.IsEmpty)
            {
                if (!z.Left.IsEmpty)
                    z.Left.Reverse().ForEach(effect);
                effect(z.Focus);
                if (!z.Right.IsEmpty)
                    z.Right.ForEach(effect);
            }
        }
    }

    /// Given the old value should and the new value should return result updated value.
    public delegate V Update<V>(V oldValue, V newValue);

    /// Update handler including the key
    public delegate V Update<K, V>(K key, V oldValue, V newValue);

    /// <summary>
    /// Fold reducer. Designed as a alternative to `Func{V, S, S}` but with possibility of inlining on the call side.
    /// Note: To get the advantage of inlining the <see cref="Reduce"/> can the interface should be implemented and passed as a NON-GENERIC STRUCT
    /// </summary>
    public interface IFoldReducer<V, S>
    {
        /// <summary>Reduce method</summary>
        S Reduce(V x, S state);
    }

    /// <summary>Immutable http://en.wikipedia.org/wiki/AVL_tree with integer keys and <typeparamref name="V"/> values.</summary>
    public sealed class ImMap<V>
    {
        /// <summary>Empty tree to start with.</summary>
        public static readonly ImMap<V> Empty = new ImMap<V>();

        /// <summary>Key.</summary>
        public int Key;

        /// <summary>Value.</summary>
        public V Value;

        /// <summary>Left sub-tree/branch, or empty.</summary>
        public ImMap<V> Left;

        /// <summary>Right sub-tree/branch, or empty.</summary>
        public ImMap<V> Right;

        /// <summary>Height of the longest sub-tree/branch. It is 0 for empty tree, and 1 for single node tree.</summary>
        public int Height;

        /// <summary>Returns true if tree is empty.</summary>
        public bool IsEmpty => Height == 0;

        /// Adds or updates the value by key in the map, always returns a modified map
        [MethodImpl((MethodImplOptions)256)]
        public ImMap<V> AddOrUpdate(int key, V value) =>
            Height == 0
                ? new ImMap<V>(key, value)
                : key == Key
                    ? new ImMap<V>(key, value, Left, Right, Height)
                    : AddOrUpdateLeftOrRight(key, value);

        private ImMap<V> AddOrUpdateLeftOrRight(int key, V value)
        {
            if (key < Key)
            {
                if (Left.Height == 0)
                    return new ImMap<V>(Key, Value, new ImMap<V>(key, value), Right, 2);

                var left = Left;
                if (left.Key == key)
                    return new ImMap<V>(Key, Value, new ImMap<V>(key, value, left.Left, left.Right, left.Height), Right,
                        Height);

                if (Right.Height == 0)
                    return key < left.Key
                        ? new ImMap<V>(left.Key, left.Value, new ImMap<V>(key, value), new ImMap<V>(Key, Value), 2)
                        : new ImMap<V>(key, value, new ImMap<V>(left.Key, left.Value), new ImMap<V>(Key, Value), 2);

                var newLeft = left.AddOrUpdateLeftOrRight(key, value);
                if (newLeft.Height > Right.Height + 1) // left is longer by 2, rotate left
                {
                    var leftLeft = newLeft.Left;
                    var leftRight = newLeft.Right;

                    if (leftLeft.Height >= leftRight.Height)
                        return new ImMap<V>(newLeft.Key, newLeft.Value,
                            leftLeft,
                            new ImMap<V>(Key, Value, leftRight, Right));

                    return new ImMap<V>(leftRight.Key, leftRight.Value,
                        new ImMap<V>(newLeft.Key, newLeft.Value, leftLeft, leftRight.Left),
                        new ImMap<V>(Key, Value, leftRight.Right, Right));
                }

                return new ImMap<V>(Key, Value, newLeft, Right);
            }
            else
            {
                if (Right.Height == 0)
                    return new ImMap<V>(Key, Value, Left, new ImMap<V>(key, value), 2);

                var right = Right;
                if (right.Key == key)
                    return new ImMap<V>(Key, Value, Left,
                        new ImMap<V>(key, value, right.Left, right.Right, right.Height), Height);

                if (Left.Height == 0)
                    return key >= right.Key
                        ? new ImMap<V>(right.Key, right.Value, new ImMap<V>(Key, Value), new ImMap<V>(key, value), 2)
                        : new ImMap<V>(key, value, new ImMap<V>(Key, Value), new ImMap<V>(right.Key, right.Value), 2);

                var newRight = right.AddOrUpdateLeftOrRight(key, value);
                if (newRight.Height > Left.Height + 1)
                {
                    var rightLeft = newRight.Left;
                    var rightRight = newRight.Right;

                    if (rightRight.Height >= rightLeft.Height)
                        return new ImMap<V>(newRight.Key, newRight.Value,
                            new ImMap<V>(Key, Value, Left, rightLeft),
                            rightRight);

                    return new ImMap<V>(rightLeft.Key, rightLeft.Value,
                        new ImMap<V>(Key, Value, Left, rightLeft.Left),
                        new ImMap<V>(newRight.Key, newRight.Value, rightLeft.Right, rightRight));
                }

                return new ImMap<V>(Key, Value, Left, newRight);
            }
        }

        /// Returns a new map with added value for the specified key or the existing map if the key is already in the map.
        [MethodImpl((MethodImplOptions)256)]
        public ImMap<V> AddOrKeep(int key, V value) =>
            Height == 0
                ? new ImMap<V>(key, value)
                : key == Key
                    ? this
                    : AddOrKeepLeftOrRight(key, value);

        private ImMap<V> AddOrKeepLeftOrRight(int key, V value)
        {
            if (key < Key)
            {
                if (Left.Height == 0)
                    return new ImMap<V>(Key, Value, new ImMap<V>(key, value), Right, 2);

                if (Left.Key == key)
                    return this;

                if (Right.Height == 0)
                    return key < Left.Key
                        ? new ImMap<V>(Left.Key, Left.Value, new ImMap<V>(key, value), new ImMap<V>(Key, Value), 2)
                        : new ImMap<V>(key, value, new ImMap<V>(Left.Key, Left.Value), new ImMap<V>(Key, Value), 2);

                var newLeft = Left.AddOrKeepLeftOrRight(key, value);
                if (ReferenceEquals(newLeft, Left))
                    return this;

                if (newLeft.Height > Right.Height + 1) // left is longer by 2, rotate left
                {
                    var leftLeft = newLeft.Left;
                    var leftRight = newLeft.Right;

                    if (leftLeft.Height >= leftRight.Height)
                        return new ImMap<V>(newLeft.Key, newLeft.Value,
                            leftLeft, new ImMap<V>(Key, Value, leftRight, Right));

                    return new ImMap<V>(leftRight.Key, leftRight.Value,
                        new ImMap<V>(newLeft.Key, newLeft.Value, leftLeft, leftRight.Left),
                        new ImMap<V>(Key, Value, leftRight.Right, Right));
                }

                return new ImMap<V>(Key, Value, newLeft, Right);
            }
            else
            {
                if (Right.Height == 0)
                    return new ImMap<V>(Key, Value, Left, new ImMap<V>(key, value), 2);

                if (Right.Key == key)
                    return this;

                if (Left.Height == 0)
                    return key >= Right.Key
                        ? new ImMap<V>(Right.Key, Right.Value, new ImMap<V>(Key, Value), new ImMap<V>(key, value), 2)
                        : new ImMap<V>(key, value, new ImMap<V>(Key, Value), new ImMap<V>(Right.Key, Right.Value), 2);

                var newRight = Right.AddOrKeepLeftOrRight(key, value);
                if (ReferenceEquals(newRight, Right))
                    return this;

                if (newRight.Height > Left.Height + 1)
                {
                    var rightLeft = newRight.Left;
                    var rightRight = newRight.Right;

                    if (rightRight.Height >= rightLeft.Height)
                        return new ImMap<V>(newRight.Key, newRight.Value,
                            new ImMap<V>(Key, Value, Left, rightLeft), rightRight);

                    return new ImMap<V>(rightLeft.Key, rightLeft.Value,
                        new ImMap<V>(Key, Value, Left, rightLeft.Left),
                        new ImMap<V>(newRight.Key, newRight.Value, rightLeft.Right, rightRight));
                }

                return new ImMap<V>(Key, Value, Left, newRight);
            }
        }

        /// Returns the new map with added or updated value for the specified key.
        [MethodImpl((MethodImplOptions)256)]
        public ImMap<V> AddOrUpdate(int key, V value, Update<int, V> updateValue) =>
            Height == 0
            ? new ImMap<V>(key, value)
            : key == Key
                ? new ImMap<V>(key, updateValue(key, Value, value), Left, Right, Height)
                : AddOrUpdateLeftOrRightWithUpdate(key, value, updateValue);

        private ImMap<V> AddOrUpdateLeftOrRightWithUpdate(int key, V value, Update<int, V> updateValue)
        {
            if (key < Key)
            {
                if (Left.Height == 0)
                    return new ImMap<V>(Key, Value, new ImMap<V>(key, value), Right, 2);

                if (Left.Key == key)
                {
                    var left = Left;
                    return new ImMap<V>(Key, Value,
                        new ImMap<V>(key, updateValue(key, left.Value, value), left.Left, left.Right, left.Height),
                        Right, Height);
                }

                if (Right.Height == 0)
                    return key < Left.Key
                        ? new ImMap<V>(Left.Key, Left.Value, new ImMap<V>(key, value), new ImMap<V>(Key, Value), 2)
                        : new ImMap<V>(key, value, new ImMap<V>(Left.Key, Left.Value), new ImMap<V>(Key, Value), 2);

                var newLeft = Left.AddOrUpdateLeftOrRightWithUpdate(key, value, updateValue);

                if (newLeft.Height > Right.Height + 1) // left is longer by 2, rotate left
                {
                    var leftLeft = newLeft.Left;
                    var leftRight = newLeft.Right;

                    if (leftLeft.Height >= leftRight.Height)
                        return new ImMap<V>(newLeft.Key, newLeft.Value,
                            leftLeft, new ImMap<V>(Key, Value, leftRight, Right));

                    return new ImMap<V>(leftRight.Key, leftRight.Value,
                        new ImMap<V>(newLeft.Key, newLeft.Value, leftLeft, leftRight.Left),
                        new ImMap<V>(Key, Value, leftRight.Right, Right));
                }

                return new ImMap<V>(Key, Value, newLeft, Right);
            }
            else
            {
                if (Right.Height == 0)
                    return new ImMap<V>(Key, Value, Left, new ImMap<V>(key, value), 2);

                if (Right.Key == key)
                {
                    var right = Right;
                    return new ImMap<V>(Key, Value, Left,
                        new ImMap<V>(key, updateValue(key, right.Value, value), right.Left, right.Right, right.Height),
                        Height);
                }

                if (Left.Height == 0)
                    return key >= Right.Key
                        ? new ImMap<V>(Right.Key, Right.Value, new ImMap<V>(Key, Value), new ImMap<V>(key, value), 2)
                        : new ImMap<V>(key, value, new ImMap<V>(Key, Value), new ImMap<V>(Right.Key, Right.Value), 2);

                var newRight = Right.AddOrUpdateLeftOrRightWithUpdate(key, value, updateValue);

                if (newRight.Height > Left.Height + 1)
                {
                    var rightLeft = newRight.Left;
                    var rightRight = newRight.Right;

                    if (rightRight.Height >= rightLeft.Height)
                        return new ImMap<V>(newRight.Key, newRight.Value,
                            new ImMap<V>(Key, Value, Left, rightLeft), rightRight);

                    return new ImMap<V>(rightLeft.Key, rightLeft.Value,
                        new ImMap<V>(Key, Value, Left, rightLeft.Left),
                        new ImMap<V>(newRight.Key, newRight.Value, rightLeft.Right, rightRight));
                }

                return new ImMap<V>(Key, Value, Left, newRight);
            }
        }

        ///<summary>Returns the new map with the updated value for the key, or the same map if the key was not found.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public ImMap<V> Update(int key, V value) =>
            this.TryFind(key, out _) ? UpdateImpl(key, value) : this;

        internal ImMap<V> UpdateImpl(int key, V value) =>
            key < Key ? new ImMap<V>(Key, Value, Left.UpdateImpl(key, value), Right, Height)
          : key > Key ? new ImMap<V>(Key, Value, Left, Right.UpdateImpl(key, value), Height)
          : new ImMap<V>(key, value, Left, Right, Height);

        /// <summary>
        /// Returns all map tree nodes enumerated from the lesser to the bigger keys
        /// </summary>
        public IEnumerable<ImMap<V>> Enumerate(ImMap<V>[] parentStack = null)
        {
            if (Height == 0)
                yield break;

            if (Height == 1)
            {
                yield return this;
            }
            else if (Height == 2)
            {
                if (Left.Height != 0)
                    yield return Left;
                yield return this;
                if (Right.Height != 0)
                    yield return Right;
            }
            else
            {
                parentStack = parentStack ?? new ImMap<V>[Height - 2];
                var map = this;
                var parentIndex = -1;
                while (map.Height != 0)
                {
                    if (map.Height == 1)
                    {
                        yield return map;
                        if (parentIndex == -1)
                            break;
                        yield return map = parentStack[parentIndex--];
                        map = map.Right;
                    }
                    else if (map.Height == 2)
                    {
                        if (map.Left.Height != 0)
                            yield return map.Left;
                        yield return map;
                        if (map.Right.Height != 0)
                            yield return map.Right;
                        if (parentIndex == -1)
                            break;
                        yield return map = parentStack[parentIndex--];
                        map = map.Right;
                    }
                    else
                    {
                        parentStack[++parentIndex] = map;
                        map = map.Left;
                    }
                }
            }
        }

        // todo: add `FindFirst`
        /// <summary>
        /// Folds all the map nodes with the state from left to right and from the bottom to top
        /// You may pass `parentStacks` to reuse the array memory.
        /// NOTE: the length of `parentStack` should be at least of map height, content is not important and could be erased.
        /// </summary>
        public S Fold<S>(S state, Func<ImMap<V>, S, S> reduce, ImMap<V>[] parentStack = null)
        {
            if (Height == 0)
                return state;

            if (Height == 1)
                return reduce(this, state);

            if (Height == 2)
                return this.ReduceTwoLevelTree(state, reduce);

            parentStack = parentStack ?? new ImMap<V>[Height - 2];
            var map = this;
            var parentIndex = -1;
            do
            {
                if (map.Height == 1)
                {
                    state = reduce(map, state);
                    if (parentIndex == -1)
                        break;
                    state = reduce(map = parentStack[parentIndex--], state);
                    map = map.Right;
                }
                else if (map.Height == 2)
                {
                    state = map.ReduceTwoLevelTree(state, reduce);
                    if (parentIndex == -1)
                        break;
                    state = reduce(map = parentStack[parentIndex--], state);
                    map = map.Right;
                }
                else
                {
                    parentStack[++parentIndex] = map;
                    map = map.Left;
                }
            } while (map.Height != 0);

            return state;
        }

        /// <summary>
        /// Folds all the map nodes with the state from left to right and from the bottom to top
        /// You may pass `parentStacks` to reuse the array memory.
        /// NOTE: the length of `parentStack` should be at least of map height, content is not important and could be erased.
        /// </summary>
        public S Fold<S, R>(S state, R reducer, ImMap<V>[] parentStack = null) where R : struct, IFoldReducer<ImMap<V>, S>
        {
            if (Height == 0)
                return state;

            if (Height == 1)
                return reducer.Reduce(this, state);

            if (Height == 2)
                return this.ReduceTwoLevelTree(state, reducer);

            parentStack = parentStack ?? new ImMap<V>[Height - 2];
            var map = this;
            var parentIndex = -1;
            do
            {
                if (map.Height == 1)
                {
                    state = reducer.Reduce(map, state);
                    if (parentIndex == -1)
                        break;
                    state = reducer.Reduce(map = parentStack[parentIndex--], state);
                    map = map.Right;
                }
                else if (map.Height == 2)
                {
                    state = map.ReduceTwoLevelTree(state, reducer);
                    if (parentIndex == -1)
                        break;
                    state = reducer.Reduce(map = parentStack[parentIndex--], state);
                    map = map.Right;
                }
                else
                {
                    parentStack[++parentIndex] = map;
                    map = map.Left;
                }
            } while (map.Height != 0);

            return state;
        }


        /// <summary>
        /// Folds all the map nodes with the state and index from left to right and from bottom to top
        /// You may pass `parentStacks` to reuse the array memory.
        /// NOTE: the length of `parentStack` should be at least of map height, content is not important and could be erased.
        /// </summary>
        public S Fold<S>(S state, Func<ImMap<V>, int, S, S> reduce, ImMap<V>[] parentStack = null)
        {
            if (Height == 0)
                return state;

            if (Height == 1)
                return reduce(this, 0, state);

            if (Height == 2)
            {
                if (Left.Height != 0)
                    state = reduce(Left, 0, state);
                state = reduce(this, 1, state);
                if (Right.Height != 0)
                    state = reduce(Right, 2, state);
                return state;
            }

            parentStack = parentStack ?? new ImMap<V>[Height - 2];
            var map = this;
            var parentIndex = -1;
            var index = 0;
            do
            {
                if (map.Height == 1)
                {
                    state = reduce(map, index++, state);
                    if (parentIndex == -1)
                        break;
                    state = reduce(map = parentStack[parentIndex--], index++, state);
                    map = map.Right;
                }
                else if (map.Height == 2)
                {
                    if (map.Left.Height != 0)
                        state = reduce(Left, index++, state);
                    state = reduce(map, index++, state);
                    if (Right.Height != 0)
                        state = reduce(map.Right, index++, state);
                    if (parentIndex == -1)
                        break;
                    state = reduce(map = parentStack[parentIndex--], index++, state);
                    map = map.Right;
                }
                else
                {
                    parentStack[++parentIndex] = map;
                    map = map.Left;
                }
            } while (map.Height != 0);

            return state;
        }

        /// <summary>Removes or updates value for specified key, or does nothing if key is not found.
        /// Based on Eric Lippert http://blogs.msdn.com/b/ericlippert/archive/2008/01/21/immutability-in-c-part-nine-academic-plus-my-avl-tree-implementation.aspx </summary>
        /// <param name="key">Key to look for.</param> 
        /// <returns>New tree with removed or updated value.</returns>
        [MethodImpl((MethodImplOptions)256)]
        public ImMap<V> Remove(int key)
        {
            if (Height == 0)
                return this;

            if (key == Key) // we've found the node to remove
            {
                if (Height == 1) // remove the leaf node
                    return Empty;

                // if we have the on child remaining then just return it
                if (Right.Height == 0)
                    return Left;

                if (Left.Height == 0)
                    return Right;

                // we have two children,
                // so remove the next highest node and replace this node with it.
                var successor = Right;
                while (successor.Left.Height != 0)
                    successor = successor.Left;
                return new ImMap<V>(successor.Key, successor.Value,
                    Left, Right.Remove(successor.Key));
            }

            // remove the node and balance the new tree
            return key < Key
                ? Balance(Key, Value, Left.Remove(key), Right)
                : Balance(Key, Value, Left, Right.Remove(key));
        }

        /// <summary>Outputs key value pair</summary>
        public override string ToString() => IsEmpty ? "empty" : Key + ":" + Value;

        internal ImMap() { }

        internal ImMap(int key, V value)
        {
            Key = key;
            Value = value;
            Left = Empty;
            Right = Empty;
            Height = 1;
        }

        internal ImMap(int key, V value, ImMap<V> left, ImMap<V> right, int height)
        {
            Key = key;
            Value = value;
            Left = left;
            Right = right;
            Height = height;
        }

        internal ImMap(int key, V value, ImMap<V> left, ImMap<V> right)
        {
            Key = key;
            Value = value;
            Left = left;
            Right = right;
            Height = left.Height > right.Height ? left.Height + 1 : right.Height + 1;
        }

        internal static ImMap<V> Balance(int key, V value, ImMap<V> left, ImMap<V> right)
        {
            var delta = left.Height - right.Height;
            if (delta > 1) // left is longer by 2, rotate left
            {
                var leftLeft = left.Left;
                var leftRight = left.Right;
                if (leftRight.Height > leftLeft.Height)
                {
                    // double rotation:
                    //      5     =>     5     =>     4
                    //   2     6      4     6      2     5
                    // 1   4        2   3        1   3     6
                    //    3        1
                    return new ImMap<V>(leftRight.Key, leftRight.Value,
                        new ImMap<V>(left.Key, left.Value, leftLeft, leftRight.Left),
                        new ImMap<V>(key, value, leftRight.Right, right));
                }

                // single rotation:
                //      5     =>     2
                //   2     6      1     5
                // 1   4              4   6
                return new ImMap<V>(left.Key, left.Value,
                    leftLeft,
                    new ImMap<V>(key, value, leftRight, right));
            }

            if (delta < -1)
            {
                var rightLeft = right.Left;
                var rightRight = right.Right;
                if (rightLeft.Height > rightRight.Height)
                {
                    return new ImMap<V>(rightLeft.Key, rightLeft.Value,
                        new ImMap<V>(key, value, left, rightLeft.Left),
                        new ImMap<V>(right.Key, right.Value, rightLeft.Right, rightRight));
                }

                return new ImMap<V>(right.Key, right.Value,
                    new ImMap<V>(key, value, left, rightLeft),
                    rightRight);
            }

            return new ImMap<V>(key, value, left, right);
        }
    }

    /// ImMap static methods
    public static class ImMap
    {
        internal static V IgnoreKey<K, V>(this Update<V> update, K _, V oldValue, V newValue) => update(oldValue, newValue);

        /// Get value for found key or the default value otherwise.
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<V>(this ImMap<V> map, int key)
        {
            while (map.Height != 0 && map.Key != key)
                map = key < map.Key ? map.Left : map.Right;
            return map.Value; // that's fine to return the value without check, because for we have a default value in empty map
        }

        /// Get value for found key or the specified default value otherwise.
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<V>(this ImMap<V> map, int key, V defaultValue)
        {
            while (map.Height != 0 && map.Key != key)
                map = key < map.Key ? map.Left : map.Right;
            return map.Height != 0 ? map.Value : defaultValue;
        }

        /// Returns true if key is found and sets the value.
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<V>(this ImMap<V> map, int key, out V value)
        {
            while (map.Height != 0)
            {
                if (key < map.Key)
                    map = map.Left;
                else if (key > map.Key)
                    map = map.Right;
                else
                    break;
            }

            value = map.Value;
            return map.Height != 0;
        }

        [MethodImpl((MethodImplOptions)256)]
        internal static S ReduceTwoLevelTree<V, S>(this ImMap<V> map, S state, Func<ImMap<V>, S, S> reduce)
        {
            if (map.Left.Height != 0)
                state = reduce(map.Left, state);
            state = reduce(map, state);
            if (map.Right.Height != 0)
                state = reduce(map.Right, state);
            return state;
        }

        [MethodImpl((MethodImplOptions)256)]
        internal static S ReduceTwoLevelTree<V, S, R>(this ImMap<V> map, S state, R reducer) where R : struct, IFoldReducer<ImMap<V>, S>
        {
            if (map.Left.Height != 0)
                state = reducer.Reduce(map.Left, state);
            state = reducer.Reduce(map, state);
            if (map.Right.Height != 0)
                state = reducer.Reduce(map.Right, state);
            return state;
        }
    }

    /// <summary>
    /// The array of ImMap slots where the key first bits are used for FAST slot location
    /// and the slot is the reference to ImMap that can be swapped with its updated value
    /// </summary>
    public static class ImMapSlots
    {
        /// Default number of slots
        public const int SLOT_COUNT_POWER_OF_TWO = 32;

        /// The default mask to partition the key to the target slot
        public const int KEY_MASK_TO_FIND_SLOT = SLOT_COUNT_POWER_OF_TWO - 1;

        /// Creates the array with the empty slots
        [MethodImpl((MethodImplOptions)256)]
        public static ImMap<V>[] CreateWithEmpty<V>(int slotCountPowerOfTwo = SLOT_COUNT_POWER_OF_TWO)
        {
            var slots = new ImMap<V>[slotCountPowerOfTwo];
            for (var i = 0; i < slots.Length; ++i)
                slots[i] = ImMap<V>.Empty;
            return slots;
        }

        /// Returns a new tree with added or updated value for specified key.
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrUpdate<V>(this ImMap<V>[] slots, int key, V value, int keyMaskToFindSlot = KEY_MASK_TO_FIND_SLOT)
        {
            ref var slot = ref slots[key & keyMaskToFindSlot];
            var copy = slot;
            if (Interlocked.CompareExchange(ref slot, copy.AddOrUpdate(key, value), copy) != copy)
                RefAddOrUpdateSlot(ref slot, key, value);
        }

        /// Update the ref to the slot with the new version - retry if the someone changed the slot in between
        public static void RefAddOrUpdateSlot<V>(ref ImMap<V> slot, int key, V value) =>
            Ref.Swap(ref slot, key, value, (x, k, v) => x.AddOrUpdate(k, v));

        /// Updates the value with help of `updateValue` function
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrUpdate<V>(this ImMap<V>[] slots, int key, V value, Update<int, V> updateValue, int keyMaskToFindSlot = KEY_MASK_TO_FIND_SLOT)
        {
            ref var slot = ref slots[key & keyMaskToFindSlot];
            var copy = slot;
            if (Interlocked.CompareExchange(ref slot, copy.AddOrUpdate(key, value, updateValue), copy) != copy)
                RefAddOrUpdateSlot(ref slot, key, value, updateValue);
        }

        /// Update the ref to the slot with the new version - retry if the someone changed the slot in between
        public static void RefAddOrUpdateSlot<V>(ref ImMap<V> slot, int key, V value, Update<int, V> updateValue) =>
            Ref.Swap(ref slot, key, value, updateValue, (s, k, v, u) => s.AddOrUpdate(k, v, u));

        /// Adds a new value for the specified key or keeps the existing map if the key is already in the map.
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrKeep<V>(this ImMap<V>[] slots, int key, V value, int keyMaskToFindSlot = KEY_MASK_TO_FIND_SLOT)
        {
            ref var slot = ref slots[key & keyMaskToFindSlot];
            var copy = slot;
            if (Interlocked.CompareExchange(ref slot, copy.AddOrKeep(key, value), copy) != copy)
                RefAddOrKeepSlot(ref slot, key, value);
        }

        /// Update the ref to the slot with the new version - retry if the someone changed the slot in between
        public static void RefAddOrKeepSlot<V>(ref ImMap<V> slot, int key, V value) =>
            Ref.Swap(ref slot, key, value, (s, k, v) => s.AddOrKeep(k, v));

        /// Updates the specified slot or does not change it
        [MethodImpl((MethodImplOptions)256)]
        public static void Update<V>(this ImMap<V>[] slots, int key, V value, int keyMaskToFindSlot = KEY_MASK_TO_FIND_SLOT)
        {
            ref var slot = ref slots[key & keyMaskToFindSlot];
            var copy = slot;
            if (Interlocked.CompareExchange(ref slot, copy.Update(key, value), copy) != copy)
                RefUpdateSlot(ref slot, key, value);
        }

        /// Update the ref to the slot with the new version - retry if the someone changed the slot in between
        public static void RefUpdateSlot<V>(ref ImMap<V> slot, int key, V value) =>
            Ref.Swap(ref slot, key, value, (s, k, v) => s.Update(k, v));

        /// <summary> Folds all map tree nodes without the order </summary>
        public static S Fold<V, S>(this ImMap<V>[] slots, S state, Func<ImMap<V>, S, S> reduce)
        {
            var parentStack = ArrayTools.Empty<ImMap<V>>();
            for (var i = 0; i < slots.Length; i++)
            {
                var map = slots[i];
                var height = map.Height;
                if (height == 0)
                    continue;
                if (height == 1)
                    state = reduce(map, state);
                else if (height == 2)
                    state = map.ReduceTwoLevelTree(state, reduce);
                else
                {
                    if (parentStack.Length < height - 2)
                        parentStack = new ImMap<V>[height - 2];
                    var parentIndex = -1;
                    do
                    {
                        if (map.Height == 1)
                        {
                            state = reduce(map, state);
                            if (parentIndex == -1)
                                break;
                            state = reduce(map = parentStack[parentIndex--], state);
                            map = map.Right;
                        }
                        else if (map.Height == 2)
                        {
                            state = map.ReduceTwoLevelTree(state, reduce);
                            if (parentIndex == -1)
                                break;
                            state = reduce(map = parentStack[parentIndex--], state);
                            map = map.Right;
                        }
                        else
                        {
                            parentStack[++parentIndex] = map;
                            map = map.Left;
                        }
                    } while (map.Height != 0);
                }
            }

            return state;
        }
    }

    /// <summary>Wraps the stored data with "fixed" reference semantics - when added to the tree it did not change or reconstructed in memory</summary>
    public class ImHashMapEntry<K, V>
    {
        /// Empty thingy
        public static readonly ImHashMapEntry<K, V> Empty = new ImHashMapEntry<K, V>();

        /// Key hash
        public readonly int Hash;

        ///  The key
        public readonly K Key;

        /// The value - may be mutated implementing the Ref CAS semantics if needed
        public V Value;

        private ImHashMapEntry() { }

        /// Constructs the data
        public ImHashMapEntry(int hash, K key, V value)
        {
            Hash = hash;
            Key = key;
            Value = value;
        }

        /// Constructs the data with the default value
        public ImHashMapEntry(int hash, K key)
        {
            Hash = hash;
            Key = key;
        }

        /// <summary>Outputs the brief tree info - mostly for debugging purposes</summary>
        public override string ToString() => Key + ": " + Value;
    }

    /// Stores ALL the data in `Conflicts` array, the fields except the `hash` are just fillers.
    /// This way we preserve the once created `ImHashMapData` so that client can hold the reference to it and update the Value if needed.
    public sealed class ImHashMapConflicts<K, V> : ImHashMapEntry<K, V>
    {
        /// Conflicted data
        public readonly ImHashMapEntry<K, V>[] Conflicts;

        /// <inheritdoc />
        public ImHashMapConflicts(int hash, params ImHashMapEntry<K, V>[] conflicts) : base(hash, default, default) =>
            Conflicts = conflicts;
    }

    /// Immutable http://en.wikipedia.org/wiki/AVL_tree 
    /// where node key is the hash code of <typeparamref name="K"/>
    public sealed class ImHashMap<K, V>
    {
        /// Empty map to start with.
        public static readonly ImHashMap<K, V> Empty = new ImHashMap<K, V>();

        /// <summary>Calculated key hash.</summary>
        public int Hash
        {
            [MethodImpl((MethodImplOptions)256)]
            get => Entry.Hash;
        }

        /// <summary>Key of type K that should support <see cref="object.Equals(object)"/> and <see cref="object.GetHashCode"/>.</summary>
        public K Key
        {
            [MethodImpl((MethodImplOptions)256)]
            get => Entry.Key;
        }

        /// <summary>Value of any type V.</summary>
        public V Value
        {
            [MethodImpl((MethodImplOptions)256)]
            get => Entry.Value;
        }

        /// <summary>In case of <see cref="Hash"/> conflicts for different keys contains conflicted keys with their values.</summary>
        public ImHashMapEntry<K, V>[] Conflicts
        {
            [MethodImpl((MethodImplOptions)256)]
            get => (Entry as ImHashMapConflicts<K, V>)?.Conflicts;
        }

        /// <summary>Left sub-tree/branch, or empty.</summary>
        public ImHashMap<K, V> Left;

        /// <summary>Right sub-tree/branch, or empty.</summary>
        public ImHashMap<K, V> Right;

        /// <summary>Height of longest sub-tree/branch plus 1. It is 0 for empty tree, and 1 for single node tree.</summary>
        public int Height;

        /// <summary>Returns true if tree is empty.</summary>
        public bool IsEmpty => Height == 0;

        /// <summary>The entry which is allocated once and can be used as a "fixed" reference to the Key and Value</summary>
        public readonly ImHashMapEntry<K, V> Entry;

        internal ImHashMap() => Entry = ImHashMapEntry<K, V>.Empty;

        /// Creates  leaf node
        public ImHashMap(int hash, K key, V value)
        {
            Entry = new ImHashMapEntry<K, V>(hash, key, value);
            Left = Empty;
            Right = Empty;
            Height = 1;
        }

        /// Creates a leaf node with default value
        public ImHashMap(int hash, K key)
        {
            Entry = new ImHashMapEntry<K, V>(hash, key);
            Left = Empty;
            Right = Empty;
            Height = 1;
        }

        /// Creates a leaf node
        public ImHashMap(ImHashMapEntry<K, V> entry)
        {
            Entry = entry;
            Left = Empty;
            Right = Empty;
            Height = 1;
        }

        /// Creates the tree and calculates the height for you
        public ImHashMap(ImHashMapEntry<K, V> entry, ImHashMap<K, V> left, ImHashMap<K, V> right)
        {
            Entry = entry;
            Left = left;
            Right = right;
            Height = 1 + (left.Height > right.Height ? left.Height : right.Height);
        }

        /// Creates the tree with the known height
        public ImHashMap(ImHashMapEntry<K, V> entry, ImHashMap<K, V> left, ImHashMap<K, V> right, int height)
        {
            Entry = entry;
            Left = left;
            Right = right;
            Height = height;
        }

        /// <summary>Outputs the brief tree info - mostly for debugging purposes</summary>
        public override string ToString() => Height == 0 ? "empty"
            : "(" + Entry
            + ") -> (" + (Left.Height == 0 ? "empty" : Left.Entry + " of height " + Left.Height)
            + ", " + (Right.Height == 0 ? "empty" : Right.Entry + " of height " + Right.Height)
            + ")";

        /// <summary>Uses the user provided hash and adds and updates the tree with passed key-value. Returns a new tree.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> AddOrUpdate(int hash, K key, V value) =>
            Height == 0 ? new ImHashMap<K, V>(hash, key, value)
            : hash == Hash ? UpdateValueOrAddOrUpdateConflict(hash, key, value)
            : AddOrUpdateLeftOrRight(hash, key, value);

        /// Adds and updates the tree with passed key-value. Returns a new tree.
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> AddOrUpdate(K key, V value) =>
            AddOrUpdate(key.GetHashCode(), key, value);

        private ImHashMap<K, V> UpdateValueOrAddOrUpdateConflict(int hash, K key, V value)
        {
            var conflictsData = Entry as ImHashMapConflicts<K, V>;
            return conflictsData == null && (ReferenceEquals(key, Key) || key.Equals(Key))
                ? new ImHashMap<K, V>(new ImHashMapEntry<K, V>(hash, key, value), Left, Right, Height)
                : AddOrUpdateConflict(conflictsData, hash, key, value);
        }

        internal enum DoAddOrUpdateConflicts { AddOrUpdate, AddOrKeep, Update }

        private ImHashMap<K, V> AddOrUpdateConflict(ImHashMapConflicts<K, V> conflictsData, int hash, K key, V value,
            Update<K, V> update = null, DoAddOrUpdateConflicts doWhat = DoAddOrUpdateConflicts.AddOrUpdate)
        {
            if (conflictsData == null)
                return doWhat == DoAddOrUpdateConflicts.Update
                    ? this
                    : new ImHashMap<K, V>(
                        new ImHashMapConflicts<K, V>(hash, Entry, new ImHashMapEntry<K, V>(hash, key, value)),
                        Left, Right, Height);

            var conflicts = conflictsData.Conflicts;
            var conflictCount = conflicts.Length;
            var conflictIndex = conflictCount - 1;
            while (conflictIndex != -1 && !key.Equals(conflicts[conflictIndex].Key))
                --conflictIndex;

            ImHashMapEntry<K, V>[] newConflicts;
            if (conflictIndex != -1)
            {
                if (doWhat == DoAddOrUpdateConflicts.AddOrKeep)
                    return this;

                // update the existing conflicted value
                newConflicts = new ImHashMapEntry<K, V>[conflictCount];
                Array.Copy(conflicts, 0, newConflicts, 0, conflictCount);
                var newValue = update == null ? value : update(key, conflicts[conflictIndex].Value, value);
                newConflicts[conflictIndex] = new ImHashMapEntry<K, V>(hash, key, newValue);
            }
            else
            {
                if (doWhat == DoAddOrUpdateConflicts.Update)
                    return this;

                // add the new conflicting value
                newConflicts = new ImHashMapEntry<K, V>[conflictCount + 1];
                Array.Copy(conflicts, 0, newConflicts, 0, conflictCount);
                newConflicts[conflictCount] = new ImHashMapEntry<K, V>(hash, key, value);
            }

            return new ImHashMap<K, V>(new ImHashMapConflicts<K, V>(hash, newConflicts), Left, Right, Height);
        }

        private ImHashMap<K, V> AddOrUpdateLeftOrRight(int hash, K key, V value)
        {
            if (hash < Hash)
            {
                if (Left.Height == 0)
                    return new ImHashMap<K, V>(Entry, new ImHashMap<K, V>(hash, key, value), Right, 2);

                if (Left.Hash == hash)
                    return new ImHashMap<K, V>(Entry, Left.UpdateValueOrAddOrUpdateConflict(hash, key, value), Right, Height);

                if (Right.Height == 0)
                {
                    if (hash < Left.Hash)
                        return new ImHashMap<K, V>(Left.Entry,
                            new ImHashMap<K, V>(hash, key, value), new ImHashMap<K, V>(Entry), 2);

                    return new ImHashMap<K, V>(new ImHashMapEntry<K, V>(hash, key, value),
                        new ImHashMap<K, V>(Left.Entry), new ImHashMap<K, V>(Entry), 2);
                }

                var left = Left.AddOrUpdateLeftOrRight(hash, key, value);
                return left.Height > Right.Height + 1
                    ? BalanceNewLeftTree(left)
                    : new ImHashMap<K, V>(Entry, left, Right);
            }
            else
            {
                if (Right.Height == 0)
                    return new ImHashMap<K, V>(Entry, Left, new ImHashMap<K, V>(hash, key, value), 2);

                if (Right.Hash == hash)
                    return new ImHashMap<K, V>(Entry, Left, Right.UpdateValueOrAddOrUpdateConflict(hash, key, value), Height);

                if (Left.Height == 0)
                {
                    if (hash < Right.Hash)
                        return new ImHashMap<K, V>(new ImHashMapEntry<K, V>(hash, key, value),
                            new ImHashMap<K, V>(Entry), new ImHashMap<K, V>(Right.Entry), 2);

                    return new ImHashMap<K, V>(Right.Entry,
                        new ImHashMap<K, V>(Entry), new ImHashMap<K, V>(hash, key, value), 2);
                }

                var right = Right.AddOrUpdateLeftOrRight(hash, key, value);
                return right.Height > Left.Height + 1
                    ? BalanceNewRightTree(right)
                    : new ImHashMap<K, V>(Entry, Left, right);
            }
        }

        private ImHashMap<K, V> BalanceNewLeftTree(ImHashMap<K, V> newLeftTree)
        {
            var leftLeft = newLeftTree.Left;
            var leftLeftHeight = leftLeft.Height;

            var leftRight = newLeftTree.Right;
            var leftRightHeight = leftRight.Height;

            if (leftRightHeight > leftLeftHeight)
            {
                newLeftTree.Right = leftRight.Left;
                newLeftTree.Height = leftLeftHeight + 1;
                return new ImHashMap<K, V>(leftRight.Entry,
                    newLeftTree,
                    new ImHashMap<K, V>(Entry, leftRight.Right, Right, Right.Height + 1),
                    leftLeftHeight + 2);

                //return new ImHashMap<K, V>(leftRight.Entry,
                //    new ImHashMap<K, V>(newLeftTree.Entry, leftLeft, leftRight.Left),
                //    new ImHashMap<K, V>(Entry, leftRight.Right, Right));
            }

            newLeftTree.Right = new ImHashMap<K, V>(Entry, leftRight, Right, leftRightHeight + 1);
            newLeftTree.Height = leftRightHeight + 2;
            return newLeftTree;

            //return new ImHashMap<K, V>(newLeftTree.Entry,
            //    leftLeft, new ImHashMap<K, V>(Entry, leftRight, Right));
        }

        // Note that Left is by 2 less deep than `newRightTree` - means that at `newRightTree.Left/Right` is at least of Left height or deeper
        private ImHashMap<K, V> BalanceNewRightTree(ImHashMap<K, V> newRightTree)
        {
            var rightLeft = newRightTree.Left;
            var rightLeftHeight = rightLeft.Height;

            var rightRight = newRightTree.Right;
            var rightRightHeight = rightRight.Height;

            if (rightLeftHeight > rightRightHeight) // 1 greater - not 2 greater because it would be too unbalanced
            {
                newRightTree.Left = rightLeft.Right;
                // the height now should be defined by rr - because left now is shorter by 1
                newRightTree.Height = rightRightHeight + 1;
                // the whole height consequentially can be defined by `newRightTree` (rr+1) because left is consist of short Left and -2 rl.Left
                return new ImHashMap<K, V>(rightLeft.Entry,
                    // Left should be >= rightLeft.Left because it maybe rightLeft.Right which defines rl height
                    new ImHashMap<K, V>(Entry, Left, rightLeft.Left, height: Left.Height + 1),
                    newRightTree, rightRightHeight + 2);

                //return new ImHashMap<K, V>(rightLeft.Entry,
                //    new ImHashMap<K, V>(Entry, Left, rightLeft.Left),
                //    new ImHashMap<K, V>(newRightTree.Entry, rightLeft.Right, rightRight));
            }

            // we may decide on the height because the Left smaller by 2
            newRightTree.Left = new ImHashMap<K, V>(Entry, Left, rightLeft, rightLeftHeight + 1);
            // if rr was > rl by 1 than new rl+1 should be equal height to rr now, if rr was == rl than new rl wins anyway
            newRightTree.Height = rightLeftHeight + 2;
            return newRightTree;

            //return new ImHashMap<K, V>(newRightTree.Entry, new ImHashMap<K, V>(Entry, Left, rightLeft), rightRight);
        }

        /// Uses the user provided hash and adds and updates the tree with passed key-value and the update function for the existing value. Returns a new tree.
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> AddOrUpdate(int hash, K key, V value, Update<K, V> update) =>
            Height == 0 ? new ImHashMap<K, V>(hash, key, value)
            : hash == Hash ? UpdateValueOrAddOrUpdateConflict(hash, key, value, update)
            : AddOrUpdateLeftOrRightWithUpdate(hash, key, value, update);

        private ImHashMap<K, V> UpdateValueOrAddOrUpdateConflict(int hash, K key, V value, Update<K, V> update)
        {
            var conflictsData = Entry as ImHashMapConflicts<K, V>;
            return conflictsData == null && (ReferenceEquals(Key, key) || Key.Equals(key))
                ? new ImHashMap<K, V>(new ImHashMapEntry<K, V>(hash, key, update(key, Value, value)), Left, Right, Height)
                : AddOrUpdateConflict(conflictsData, hash, key, value, update);
        }

        private ImHashMap<K, V> AddOrUpdateLeftOrRightWithUpdate(int hash, K key, V value, Update<K, V> update)
        {
            if (hash < Hash)
            {
                if (Left.Height == 0)
                    return new ImHashMap<K, V>(Entry, new ImHashMap<K, V>(hash, key, value), Right, 2);

                if (Left.Hash == hash)
                    return new ImHashMap<K, V>(Entry, Left.UpdateValueOrAddOrUpdateConflict(hash, key, value, update), Right, Height);

                if (Right.Height == 0)
                {
                    if (hash < Left.Hash)
                        return new ImHashMap<K, V>(Left.Entry, new ImHashMap<K, V>(hash, key, value), new ImHashMap<K, V>(Entry), 2);

                    return new ImHashMap<K, V>(new ImHashMapEntry<K, V>(hash, key, value),
                        new ImHashMap<K, V>(Left.Entry), new ImHashMap<K, V>(Entry), 2);
                }

                var left = Left.AddOrUpdateLeftOrRightWithUpdate(hash, key, value, update);
                return left.Height > Right.Height + 1
                    ? BalanceNewLeftTree(left)
                    : new ImHashMap<K, V>(Entry, left, Right);
            }
            else
            {
                if (Right.Height == 0)
                    return new ImHashMap<K, V>(Entry, Left, new ImHashMap<K, V>(hash, key, value), 2);

                if (Right.Hash == hash)
                    return new ImHashMap<K, V>(Entry, Left, Right.UpdateValueOrAddOrUpdateConflict(hash, key, value, update), Height);

                if (Left.Height == 0)
                {
                    if (hash < Right.Hash)
                        return new ImHashMap<K, V>(new ImHashMapEntry<K, V>(hash, key, value),
                            new ImHashMap<K, V>(Entry), new ImHashMap<K, V>(Right.Entry), 2);

                    return new ImHashMap<K, V>(Right.Entry,
                        new ImHashMap<K, V>(Entry), new ImHashMap<K, V>(hash, key, value), 2);
                }

                var right = Right.AddOrUpdateLeftOrRightWithUpdate(hash, key, value, update);
                return right.Height > Left.Height + 1
                    ? BalanceNewRightTree(right)
                    : new ImHashMap<K, V>(Entry, Left, right);
            }
        }

        /// Returns a new tree with added or updated key-value. Uses the provided <paramref name="update"/> for updating the existing value.
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> AddOrUpdate(K key, V value, Update<K, V> update) =>
            AddOrUpdate(key.GetHashCode(), key, value, update);

        /// Returns a new tree with added or updated key-value. Uses the provided <paramref name="update"/> for updating the existing value.
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> AddOrUpdate(K key, V value, Update<V> update) =>
            AddOrUpdate(key.GetHashCode(), key, value, update.IgnoreKey);

        /// Adds a new value for the specified key or keeps the existing map if the key is already in the map.
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> AddOrKeep(int hash, K key, V value) =>
            Height == 0 ? new ImHashMap<K, V>(hash, key, value)
            : hash == Hash ? KeepValueOrAddConflict(hash, key, value)
            : AddOrKeepLeftOrRight(hash, key, value);

        /// Adds a new value for the specified key or keeps the existing map if the key is already in the map.
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> AddOrKeep(K key, V value) =>
            AddOrKeep(key.GetHashCode(), key, value);

        private ImHashMap<K, V> KeepValueOrAddConflict(int hash, K key, V value)
        {
            var conflictsData = Entry as ImHashMapConflicts<K, V>;
            return conflictsData == null && (ReferenceEquals(Key, key) || Key.Equals(key)) ? this
                : AddOrUpdateConflict(conflictsData, hash, key, value, null, DoAddOrUpdateConflicts.AddOrKeep);
        }
        private ImHashMap<K, V> AddOrKeepLeftOrRight(int hash, K key, V value)
        {
            if (hash < Hash)
            {
                if (Left.Height == 0)
                    return new ImHashMap<K, V>(Entry, new ImHashMap<K, V>(hash, key, value), Right, 2);

                if (Left.Hash == hash)
                {
                    var leftWithNewConflict = Left.KeepValueOrAddConflict(hash, key, value);
                    return ReferenceEquals(leftWithNewConflict, Left) ? this
                        : new ImHashMap<K, V>(Entry, leftWithNewConflict, Right, Height);
                }

                if (Right.Height == 0)
                {
                    if (hash < Left.Hash)
                        return new ImHashMap<K, V>(Left.Entry,
                            new ImHashMap<K, V>(hash, key, value), new ImHashMap<K, V>(Entry), 2);

                    return new ImHashMap<K, V>(new ImHashMapEntry<K, V>(hash, key, value),
                        new ImHashMap<K, V>(Left.Entry), new ImHashMap<K, V>(Entry), 2);
                }

                var left = Left.AddOrKeepLeftOrRight(hash, key, value);
                if (ReferenceEquals(left, Left))
                    return this;

                return left.Height > Right.Height + 1
                    ? BalanceNewLeftTree(left)
                    : new ImHashMap<K, V>(Entry, left, Right);
            }
            else
            {
                if (Right.Height == 0)
                    return new ImHashMap<K, V>(Entry, Left, new ImHashMap<K, V>(hash, key, value), 2);

                if (Right.Hash == hash)
                {
                    var rightWithNewConflict = Right.KeepValueOrAddConflict(hash, key, value);
                    return ReferenceEquals(rightWithNewConflict, Right) ? this
                        : new ImHashMap<K, V>(Entry, Left, rightWithNewConflict, Height);
                }

                if (Left.Height == 0)
                {
                    if (hash < Right.Hash)
                        return new ImHashMap<K, V>(new ImHashMapEntry<K, V>(hash, key, value),
                            new ImHashMap<K, V>(Entry), new ImHashMap<K, V>(Right.Entry), 2);

                    return new ImHashMap<K, V>(Right.Entry,
                        new ImHashMap<K, V>(Entry), new ImHashMap<K, V>(hash, key, value), 2);
                }

                var right = Right.AddOrKeepLeftOrRight(hash, key, value);
                if (ReferenceEquals(right, Right))
                    return this;

                return right.Height > Left.Height + 1
                    ? BalanceNewRightTree(right)
                    : new ImHashMap<K, V>(Entry, Left, right);
            }
        }

        /// Adds a new value for the specified key or keeps the existing map if the key is already in the map.
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> AddOrKeep(int hash, K key) =>
            Height == 0 ? new ImHashMap<K, V>(hash, key)
            : hash == Hash ? KeepValueOrAddConflict(hash, key)
            : AddOrKeepLeftOrRight(hash, key);

        /// Adds a new value for the specified key or keeps the existing map if the key is already in the map.
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> AddOrKeep(K key) =>
            AddOrKeep(key.GetHashCode(), key);

        private ImHashMap<K, V> KeepValueOrAddConflict(int hash, K key)
        {
            var conflictsData = Entry as ImHashMapConflicts<K, V>;
            return conflictsData == null && (ReferenceEquals(Key, key) || Key.Equals(key))
                ? this : AddOrKeepConflict(conflictsData, hash, key);
        }

        private ImHashMap<K, V> AddOrKeepConflict(ImHashMapConflicts<K, V> conflictsData, int hash, K key)
        {
            if (conflictsData == null)
                return new ImHashMap<K, V>(
                    new ImHashMapConflicts<K, V>(hash, Entry, new ImHashMapEntry<K, V>(hash, key)),
                    Left, Right, Height);

            var conflicts = conflictsData.Conflicts;
            var conflictCount = conflicts.Length;
            var conflictIndex = conflictCount - 1;
            while (conflictIndex != -1 && !key.Equals(conflicts[conflictIndex].Key))
                --conflictIndex;

            if (conflictIndex != -1)
                return this;

            // add the new conflicting value
            var newConflicts = new ImHashMapEntry<K, V>[conflictCount + 1];
            Array.Copy(conflicts, 0, newConflicts, 0, conflictCount);
            newConflicts[conflictCount] = new ImHashMapEntry<K, V>(hash, key);

            return new ImHashMap<K, V>(new ImHashMapConflicts<K, V>(hash, newConflicts), Left, Right, Height);
        }

        private ImHashMap<K, V> AddOrKeepLeftOrRight(int hash, K key)
        {
            if (hash < Hash)
            {
                if (Left.Height == 0)
                    return new ImHashMap<K, V>(Entry, new ImHashMap<K, V>(hash, key), Right, 2);

                if (Left.Hash == hash)
                {
                    var leftWithNewConflict = Left.KeepValueOrAddConflict(hash, key);
                    return ReferenceEquals(leftWithNewConflict, Left) ? this
                        : new ImHashMap<K, V>(Entry, leftWithNewConflict, Right, Height);
                }

                if (Right.Height == 0)
                {
                    if (hash < Left.Hash)
                        return new ImHashMap<K, V>(Left.Entry,
                            new ImHashMap<K, V>(hash, key), new ImHashMap<K, V>(Entry), 2);

                    return new ImHashMap<K, V>(new ImHashMapEntry<K, V>(hash, key),
                        new ImHashMap<K, V>(Left.Entry), new ImHashMap<K, V>(Entry), 2);
                }

                var left = Left.AddOrKeepLeftOrRight(hash, key);
                if (ReferenceEquals(left, Left))
                    return this;

                return left.Height > Right.Height + 1
                    ? BalanceNewLeftTree(left)
                    : new ImHashMap<K, V>(Entry, left, Right);
            }
            else
            {
                if (Right.Height == 0)
                    return new ImHashMap<K, V>(Entry, Left, new ImHashMap<K, V>(hash, key), 2);

                if (Right.Hash == hash)
                {
                    var rightWithNewConflict = Right.KeepValueOrAddConflict(hash, key);
                    return ReferenceEquals(rightWithNewConflict, Right) ? this
                        : new ImHashMap<K, V>(Entry, Left, rightWithNewConflict, Height);
                }

                if (Left.Height == 0)
                {
                    if (hash < Right.Hash)
                        return new ImHashMap<K, V>(new ImHashMapEntry<K, V>(hash, key),
                            new ImHashMap<K, V>(Entry), new ImHashMap<K, V>(Right.Entry), 2);

                    return new ImHashMap<K, V>(Right.Entry,
                        new ImHashMap<K, V>(Entry), new ImHashMap<K, V>(hash, key), 2);
                }

                var right = Right.AddOrKeepLeftOrRight(hash, key);
                if (ReferenceEquals(right, Right))
                    return this;

                return right.Height > Left.Height + 1
                    ? BalanceNewRightTree(right)
                    : new ImHashMap<K, V>(Entry, Left, right);
            }
        }

        /// Updates the map with the new value if key is found, otherwise returns the same unchanged map.
        public ImHashMap<K, V> Update(int hash, K key, V value, Update<K, V> update = null)
        {
            if (Height == 0)
                return this;

            // No need to balance cause we not adding or removing nodes
            if (hash < Hash)
            {
                var left = Left.Update(hash, key, value, update);
                return ReferenceEquals(left, Left) ? this : new ImHashMap<K, V>(Entry, left, Right, Height);
            }

            if (hash > Hash)
            {
                var right = Right.Update(hash, key, value, update);
                return ReferenceEquals(right, Right) ? this : new ImHashMap<K, V>(Entry, Left, right, Height);
            }

            var conflictsData = Entry as ImHashMapConflicts<K, V>;
            if (conflictsData == null && (ReferenceEquals(Key, key) || Key.Equals(key)))
                return new ImHashMap<K, V>(
                    new ImHashMapEntry<K, V>(hash, key, update == null ? value : update(key, Value, value)),
                    Left, Right, Height);

            return AddOrUpdateConflict(conflictsData, hash, key, value, update, DoAddOrUpdateConflicts.Update);
        }

        /// Updates the map with the new value if key is found, otherwise returns the same unchanged map.
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> Update(K key, V value) =>
            Update(key.GetHashCode(), key, value);

        /// Updates the map with the new value if key is found, otherwise returns the same unchanged map.
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> Update(K key, V value, Update<V> update) =>
            Update(key.GetHashCode(), key, value, update.IgnoreKey);

        /// Updates the map with the Default (null for reference types) value if key is found, otherwise returns the same unchanged map.
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> UpdateToDefault(int hash, K key)
        {
            if (Height == 0)
                return this;

            // No need to balance cause we not adding or removing nodes
            if (hash < Hash)
            {
                var left = Left.UpdateToDefault(hash, key);
                return left == Left ? this : new ImHashMap<K, V>(Entry, left, Right, Height);
            }

            if (hash > Hash)
            {
                var right = Right.UpdateToDefault(hash, key);
                return right == Right ? this : new ImHashMap<K, V>(Entry, Left, right, Height);
            }

            var conflictsData = Entry as ImHashMapConflicts<K, V>;
            if (conflictsData == null && (ReferenceEquals(Key, key) || Key.Equals(key)))
                return new ImHashMap<K, V>(new ImHashMapEntry<K, V>(hash, key), Left, Right, Height);

            return UpdateConflictToDefault(conflictsData, hash, key);
        }

        private ImHashMap<K, V> UpdateConflictToDefault(ImHashMapConflicts<K, V> conflictsData, int hash, K key)
        {
            if (conflictsData == null)
                return this;

            var conflicts = conflictsData.Conflicts;
            var conflictCount = conflicts.Length;
            var conflictIndex = conflictCount - 1;
            while (conflictIndex != -1 && !key.Equals(conflicts[conflictIndex].Key))
                --conflictIndex;

            if (conflictIndex == -1)
                return this;

            // update the existing conflicted value
            var newConflicts = new ImHashMapEntry<K, V>[conflictCount];
            Array.Copy(conflicts, 0, newConflicts, 0, conflictCount);
            newConflicts[conflictIndex] = new ImHashMapEntry<K, V>(hash, key);
            return new ImHashMap<K, V>(new ImHashMapConflicts<K, V>(hash, newConflicts), Left, Right, Height);
        }

        /// <summary>
        /// Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
        /// The only difference is using fixed size array instead of stack for speed-up.
        /// </summary>
        public IEnumerable<ImHashMapEntry<K, V>> Enumerate()
        {
            if (Height != 0)
            {
                var parents = new ImHashMap<K, V>[Height];
                var node = this;
                var parentCount = -1;
                while (node.Height != 0 || parentCount != -1)
                {
                    if (node.Height != 0)
                    {
                        parents[++parentCount] = node;
                        node = node.Left;
                    }
                    else
                    {
                        node = parents[parentCount--];
                        if (node.Entry is ImHashMapConflicts<K, V> conflictsData)
                        {
                            var conflicts = conflictsData.Conflicts;
                            for (var i = 0; i < conflicts.Length; i++)
                                yield return conflicts[i];
                        }
                        else
                        {
                            yield return node.Entry;
                        }

                        node = node.Right;
                    }
                }
            }
        }

        /// <summary>
        /// Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
        /// The only difference is using fixed size array instead of stack for speed-up.
        /// Note: By passing <paramref name="parentsStack"/> you may reuse the stack array between different method calls,
        /// but it should be at least <see cref="ImHashMap{K,V}.Height"/> length. The contents of array are not important.
        /// </summary>
        public S Fold<S>(S state, Func<ImHashMapEntry<K, V>, S, S> reduce, ImHashMap<K, V>[] parentsStack = null)
        {
            if (Height == 1 && Entry is ImHashMapConflicts<K, V> == false)
                return reduce(Entry, state);

            if (Height != 0)
            {
                parentsStack = parentsStack ?? new ImHashMap<K, V>[Height];
                var node = this;
                var parentCount = -1;
                while (node.Height != 0 || parentCount != -1)
                {
                    if (node.Height != 0)
                    {
                        parentsStack[++parentCount] = node;
                        node = node.Left;
                    }
                    else
                    {
                        node = parentsStack[parentCount--];

                        if (!(node.Entry is ImHashMapConflicts<K, V> conflicts))
                            state = reduce(node.Entry, state);
                        else
                        {
                            var conflict = conflicts.Conflicts;
                            for (var i = 0; i < conflict.Length; i++)
                                state = reduce(conflict[i], state);
                        }

                        node = node.Right;
                    }
                }
            }

            return state;
        }

        /// <summary>
        /// Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
        /// The only difference is using fixed size array instead of stack for speed-up.
        /// Note: By passing <paramref name="parentsStack"/> you may reuse the stack array between different method calls,
        /// but it should be at least <see cref="ImHashMap{K,V}.Height"/> length. The contents of array are not important.
        /// </summary>
        public S Fold<S>(S state, Func<ImHashMapEntry<K, V>, int, S, S> reduce, ImHashMap<K, V>[] parentsStack = null)
        {
            if (Height == 1 && Entry is ImHashMapConflicts<K, V> == false)
                return reduce(Entry, 0, state);

            if (Height != 0)
            {
                parentsStack = parentsStack ?? new ImHashMap<K, V>[Height];
                var index = 0;
                var node = this;
                var parentCount = -1;
                while (node.Height != 0 || parentCount != -1)
                {
                    if (node.Height != 0)
                    {
                        parentsStack[++parentCount] = node;
                        node = node.Left;
                    }
                    else
                    {
                        node = parentsStack[parentCount--];

                        if (!(node.Entry is ImHashMapConflicts<K, V> conflicts))
                            state = reduce(node.Entry, index++, state);
                        else
                        {
                            var conflictData = conflicts.Conflicts;
                            for (var i = 0; i < conflictData.Length; i++)
                                state = reduce(conflictData[i], index++, state);
                        }

                        node = node.Right;
                    }
                }
            }

            return state;
        }

        /// <summary>
        /// Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
        /// The only difference is using fixed size array instead of stack for speed-up.
        /// Note: By passing <paramref name="parentsStack"/> you may reuse the stack array between different method calls,
        /// but it should be at least <see cref="ImHashMap{K,V}.Height"/> length. The contents of array are not important.
        /// </summary>
        public S Visit<S>(S state, Action<ImHashMapEntry<K, V>, S> effect, ImHashMap<K, V>[] parentsStack = null)
        {
            if (Height == 1 && Entry is ImHashMapConflicts<K, V> == false)
            {
                effect(Entry, state);
            }
            else if (Height != 0)
            {
                parentsStack = parentsStack ?? new ImHashMap<K, V>[Height];
                var node = this;
                var parentCount = -1;
                while (node.Height != 0 || parentCount != -1)
                {
                    if (node.Height != 0)
                    {
                        parentsStack[++parentCount] = node;
                        node = node.Left;
                    }
                    else
                    {
                        node = parentsStack[parentCount--];

                        if (!(node.Entry is ImHashMapConflicts<K, V> conflicts))
                            effect(node.Entry, state);
                        else
                        {
                            var conflict = conflicts.Conflicts;
                            for (var i = 0; i < conflict.Length; i++)
                                effect(conflict[i], state);
                        }

                        node = node.Right;
                    }
                }
            }

            return state;
        }

        /// <summary>
        /// Depth-first in-order traversal as described in http://en.wikipedia.org/wiki/Tree_traversal
        /// The only difference is using fixed size array instead of stack for speed-up.
        /// Note: By passing <paramref name="parentsStack"/> you may reuse the stack array between different method calls,
        /// but it should be at least <see cref="ImHashMap{K,V}.Height"/> length. The contents of array are not important.
        /// </summary>
        public void Visit(Action<ImHashMapEntry<K, V>> effect, ImHashMap<K, V>[] parentsStack = null)
        {
            if (Height == 1 && Entry is ImHashMapConflicts<K, V> == false)
                effect(Entry);
            else if (Height != 0)
            {
                parentsStack = parentsStack ?? new ImHashMap<K, V>[Height];
                var node = this;
                var parentCount = -1;
                while (node.Height != 0 || parentCount != -1)
                {
                    if (node.Height != 0)
                    {
                        parentsStack[++parentCount] = node;
                        node = node.Left;
                    }
                    else
                    {
                        node = parentsStack[parentCount--];

                        if (!(node.Entry is ImHashMapConflicts<K, V> conflicts))
                            effect(node.Entry);
                        else
                        {
                            var conflict = conflicts.Conflicts;
                            for (var i = 0; i < conflict.Length; i++)
                                effect(conflict[i]);
                        }

                        node = node.Right;
                    }
                }
            }
        }

        /// <summary> Finds the first entry matching the condition, returns `null` if not found </summary>
        public ImHashMapEntry<K, V> FindFirstOrDefault(Func<ImHashMapEntry<K, V>, bool> condition, ImHashMap<K, V>[] parentsStack = null)
        {
            if (Height == 1 && Entry is ImHashMapConflicts<K, V> == false)
            {
                if (condition(Entry))
                    return Entry;
            }
            else if (Height != 0)
            {
                parentsStack = parentsStack ?? new ImHashMap<K, V>[Height];
                var node = this;
                var parentCount = -1;
                while (node.Height != 0 || parentCount != -1)
                {
                    if (node.Height != 0)
                    {
                        parentsStack[++parentCount] = node;
                        node = node.Left;
                    }
                    else
                    {
                        node = parentsStack[parentCount--];

                        if (!(node.Entry is ImHashMapConflicts<K, V> conflicts))
                        {
                            if (condition(node.Entry))
                                return node.Entry;
                        }
                        else
                        {
                            var conflictedEntries = conflicts.Conflicts;
                            for (var i = 0; i < conflictedEntries.Length; i++)
                                if (condition(conflictedEntries[i]))
                                    return conflictedEntries[i];
                        }

                        node = node.Right;
                    }
                }
            }

            return null;
        }

        /// Removes or updates value for specified key, or does nothing if the key is not found (returns the unchanged map)
        /// Based on Eric Lippert http://blogs.msdn.com/b/ericlippert/archive/2008/01/21/immutability-in-c-part-nine-academic-plus-my-avl-tree-implementation.aspx
        public ImHashMap<K, V> Remove(int hash, K key) =>
            RemoveImpl(hash, key);

        /// Removes or updates value for specified key, or does nothing if the key is not found (returns the unchanged map)
        /// Based on Eric Lippert http://blogs.msdn.com/b/ericlippert/archive/2008/01/21/immutability-in-c-part-nine-academic-plus-my-avl-tree-implementation.aspx
        [MethodImpl((MethodImplOptions)256)]
        public ImHashMap<K, V> Remove(K key) =>
            RemoveImpl(key.GetHashCode(), key);

        private ImHashMap<K, V> RemoveImpl(int hash, K key, bool ignoreKey = false)
        {
            if (Height == 0)
                return this;

            ImHashMap<K, V> result;
            if (hash == Hash) // found node
            {
                if (ignoreKey || Equals(Key, key))
                {
                    if (Height == 1) // remove node
                        return Empty;

                    if (Right.IsEmpty)
                        result = Left;
                    else if (Left.IsEmpty)
                        result = Right;
                    else
                    {
                        // we have two children, so remove the next highest node and replace this node with it.
                        var next = Right;
                        while (!next.Left.IsEmpty)
                            next = next.Left;
                        result = new ImHashMap<K, V>(next.Entry, Left, Right.RemoveImpl(next.Hash, default, ignoreKey: true));
                    }
                }
                else if (Entry is ImHashMapConflicts<K, V> conflictsData)
                    return TryRemoveConflicted(conflictsData, hash, key);
                else
                    return this; // if key is not matching and no conflicts to lookup - just return
            }
            else
                result = hash < Hash
                    ? Balance(Entry, Left.RemoveImpl(hash, key, ignoreKey), Right)
                    : Balance(Entry, Left, Right.RemoveImpl(hash, key, ignoreKey));

            return result;
        }

        /// <summary> Searches for the key in the conflicts and returns true if found </summary>
        public bool ContainsConflictedData(K key)
        {
            if (Conflicts is not null)
            {
                var conflicts = Conflicts;
                for (var i = 0; i < conflicts.Length; ++i)
                    if (key.Equals(conflicts[i].Key))
                        return true;
            }
            return false;
        }

        /// <summary> Searches for the key in the node conflicts </summary>
        public ImHashMapEntry<K, V> GetConflictedEntryOrDefault(K key)
        {
            if (Conflicts is not null)
            {
                var conflicts = Conflicts;
                for (var i = 0; i < conflicts.Length; ++i)
                    if (key.Equals(conflicts[i].Key))
                        return conflicts[i];
            }
            return null;
        }

        /// Searches for the key in the node conflicts
        public V GetConflictedValueOrDefault(K key, V defaultValue)
        {
            if (Conflicts is not null)
            {
                var conflicts = Conflicts;
                for (var i = 0; i < conflicts.Length; ++i)
                    if (key.Equals(conflicts[i].Key))
                        return conflicts[i].Value;
            }
            return defaultValue;
        }

        /// Searches for the key in the node conflicts
        public bool TryFindConflictedValue(K key, out V value)
        {
            if (Conflicts is not null)
            {
                var conflicts = Conflicts;
                for (var i = 0; i < conflicts.Length; ++i)
                    if (Equals(conflicts[i].Key, key))
                    {
                        value = conflicts[i].Value;
                        return true;
                    }
            }
            value = default;
            return false;
        }

        // todo: implement in terms of BalanceNewLeftTree | BalanceNewRightTree
        private static ImHashMap<K, V> Balance(ImHashMapEntry<K, V> entry, ImHashMap<K, V> left, ImHashMap<K, V> right)
        {
            var delta = left.Height - right.Height;
            if (delta > 1) // left is longer by 2, rotate left
            {
                var leftLeft = left.Left;
                var leftRight = left.Right;
                if (leftRight.Height > leftLeft.Height)
                {
                    // double rotation:
                    //      5     =>     5     =>     4
                    //   2     6      4     6      2     5
                    // 1   4        2   3        1   3     6
                    //    3        1
                    return new ImHashMap<K, V>(leftRight.Entry,
                        new ImHashMap<K, V>(left.Entry, leftLeft, leftRight.Left),
                        new ImHashMap<K, V>(entry, leftRight.Right, right));
                }

                // one rotation:
                //      5     =>     2
                //   2     6      1     5
                // 1   4              4   6
                return new ImHashMap<K, V>(left.Entry,
                    leftLeft, new ImHashMap<K, V>(entry, leftRight, right));
            }

            if (delta < -1)
            {
                var rightLeft = right.Left;
                var rightRight = right.Right;
                return rightLeft.Height > rightRight.Height
                    ? new ImHashMap<K, V>(rightLeft.Entry,
                        new ImHashMap<K, V>(entry, left, rightLeft.Left),
                        new ImHashMap<K, V>(right.Entry, rightLeft.Right, rightRight))
                    : new ImHashMap<K, V>(right.Entry, new ImHashMap<K, V>(entry, left, rightLeft), rightRight);
            }

            return new ImHashMap<K, V>(entry, left, right);
        }

        private ImHashMap<K, V> TryRemoveConflicted(ImHashMapConflicts<K, V> conflictsData, int hash, K key)
        {
            var conflicts = conflictsData.Conflicts;
            var index = conflicts.Length - 1;
            while (index != -1 && !conflicts[index].Key.Equals(key)) --index;
            if (index == -1) // key is not found in conflicts - just return
                return this;

            // we removing the one from the 2 items, so we can reference the remaining item directly from the map node 
            if (conflicts.Length == 2)
                return new ImHashMap<K, V>(index == 0 ? conflicts[1] : conflicts[0], Left, Right, Height);

            // copy all except the `index`ed data into shrinked conflicts
            var shrinkedConflicts = new ImHashMapEntry<K, V>[conflicts.Length - 1];
            var newIndex = 0;
            for (var i = 0; i < conflicts.Length; ++i)
                if (i != index)
                    shrinkedConflicts[newIndex++] = conflicts[i];
            return new ImHashMap<K, V>(new ImHashMapConflicts<K, V>(hash, shrinkedConflicts), Left, Right, Height);
        }
    }

    /// ImHashMap methods for faster performance
    public static class ImHashMap
    {
        /// <summary> Looks for key in a tree and returns `true` if found. </summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool Contains<K, V>(this ImHashMap<K, V> map, int hash, K key)
        {
            while (map.Height != 0 && map.Hash != hash)
                map = hash < map.Hash ? map.Left : map.Right;
            return map.Height != 0 && (key.Equals(map.Key) || map.ContainsConflictedData(key));
        }

        /// <summary> Looks for key in a tree and returns `true` if found. </summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool Contains<K, V>(this ImHashMap<K, V> map, K key) =>
            map.Height != 0 && map.Contains(key.GetHashCode(), key);

        /// Looks for key in a tree and returns the Data object if found or `null` otherwise.
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMapEntry<K, V> GetEntryOrDefault<K, V>(this ImHashMap<K, V> map, int hash, K key)
        {
            while (map.Height != 0 && map.Hash != hash)
                map = hash < map.Hash ? map.Left : map.Right;

            return map.Height == 0 ? null :
                key.Equals(map.Key) ? map.Entry :
                map.GetConflictedEntryOrDefault(key);
        }

        /// <summary> Looks for key in a tree and returns the Data object if found or `null` otherwise. </summary> 
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMapEntry<K, V> GetEntryOrDefault<K, V>(this ImHashMap<K, V> map, K key)
        {
            if (map.Height == 0)
                return null;

            var hash = key.GetHashCode();

            while (map.Hash != hash)
            {
                map = hash < map.Hash ? map.Left : map.Right;
                if (map.Height == 0)
                    return null;
            }

            return key.Equals(map.Key) ? map.Entry : map.GetConflictedEntryOrDefault(key);
        }

        /// Looks for key in a tree and returns the key value if found, or <paramref name="defaultValue"/> otherwise.
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V> map, K key, V defaultValue = default)
        {
            if (map.Height == 0)
                return defaultValue;

            var hash = key.GetHashCode();

            while (map.Hash != hash)
            {
                map = hash < map.Hash ? map.Left : map.Right;
                if (map.Height == 0)
                    return defaultValue;
            }

            return key.Equals(map.Key) ? map.Value : map.GetConflictedValueOrDefault(key, defaultValue);
        }

        /// Looks for key in a tree and returns the key value if found, or <paramref name="defaultValue"/> otherwise.
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V> map, int hash, K key, V defaultValue = default)
        {
            if (map.Height == 0)
                return defaultValue;

            while (map.Hash != hash)
            {
                map = hash < map.Hash ? map.Left : map.Right;
                if (map.Height == 0)
                    return defaultValue;
            }

            return key.Equals(map.Key) ? map.Value : map.GetConflictedValueOrDefault(key, defaultValue);
        }

        /// Looks for key in a tree and returns the key value if found, or <paramref name="defaultValue"/> otherwise.
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<V>(this ImHashMap<Type, V> map, Type key, V defaultValue = default)
        {
            if (map.Height == 0)
                return defaultValue;

            var hash = key.GetHashCode();
            while (hash != map.Hash)
            {
                map = hash < map.Hash ? map.Left : map.Right;
                if (map.Height == 0)
                    return defaultValue;
            }

            // we don't need to check `Height != 0` again cause in that case `key` will be `null` and `ReferenceEquals` will fail
            return ReferenceEquals(key, map.Key) ? map.Value : map.GetConflictedValueOrDefault(key, defaultValue);
        }

        /// Looks for key in a tree and returns the key value if found, or <paramref name="defaultValue"/> otherwise.
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<V>(this ImHashMap<Type, V> map, int hash, Type key, V defaultValue = default)
        {
            if (map.Height == 0)
                return defaultValue;

            while (hash != map.Hash)
            {
                map = hash < map.Hash ? map.Left : map.Right;
                if (map.Height == 0)
                    return defaultValue;
            }

            // we don't need to check `Height != 0` again cause in that case `key` will be `null` and `ReferenceEquals` will fail
            return ReferenceEquals(key, map.Key) ? map.Value : map.GetConflictedValueOrDefault(key, defaultValue);
        }

        /// Returns true if key is found and sets the value.
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<K, V>(this ImHashMap<K, V> map, K key, out V value)
        {
            if (map.Height != 0)
            {
                var hash = key.GetHashCode();

                while (hash != map.Hash && map.Height != 0)
                    map = hash < map.Hash ? map.Left : map.Right;

                if (map.Height != 0)
                {
                    if (key.Equals(map.Key))
                    {
                        value = map.Value;
                        return true;
                    }

                    return map.TryFindConflictedValue(key, out value);
                }
            }

            value = default;
            return false;
        }

        /// Returns true if key is found and sets the value.
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<K, V>(this ImHashMap<K, V> map, int hash, K key, out V value)
        {
            if (map.Height != 0)
            {
                while (hash != map.Hash && map.Height != 0)
                    map = hash < map.Hash ? map.Left : map.Right;

                if (map.Height != 0)
                {
                    if (key.Equals(map.Key))
                    {
                        value = map.Value;
                        return true;
                    }

                    return map.TryFindConflictedValue(key, out value);
                }
            }

            value = default;
            return false;
        }

        /// Returns true if key is found and the result value.
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<V>(this ImHashMap<Type, V> map, Type key, out V value)
        {
            if (map.Height != 0)
            {
                var hash = key.GetHashCode();
                while (hash != map.Hash && map.Height != 0)
                    map = hash < map.Hash ? map.Left : map.Right;

                if (map.Height != 0)
                {
                    // assign to `var data = ...`
                    if (ReferenceEquals(key, map.Key))
                    {
                        value = map.Value;
                        return true;
                    }

                    return map.TryFindConflictedValue(key, out value);
                }
            }

            value = default;
            return false;
        }

        /// Returns true if hash and key are found and the result value, or the false otherwise
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<V>(this ImHashMap<Type, V> map, int hash, Type key, out V value)
        {
            if (map.Height != 0)
            {
                while (hash != map.Hash && map.Height != 0)
                    map = hash < map.Hash ? map.Left : map.Right;

                if (map.Height != 0)
                {
                    if (ReferenceEquals(key, map.Key))
                    {
                        value = map.Value;
                        return true;
                    }

                    return map.TryFindConflictedValue(key, out value);
                }
            }

            value = default;
            return false;
        }
    }

    /// <summary>
    /// The array of ImHashMap slots where the key first bits are used for FAST slot location
    /// and the slot is the reference to ImHashMap that can be swapped with its updated value
    /// </summary>
    public static class ImHashMapSlots
    {
        /// Default number of slots
        public const int SLOT_COUNT_POWER_OF_TWO = 32;

        /// The default mask to partition the key to the target slot
        public const int HASH_MASK_TO_FIND_SLOT = SLOT_COUNT_POWER_OF_TWO - 1;

        /// Creates the array with the empty slots
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V>[] CreateWithEmpty<K, V>(int slotCountPowerOfTwo = SLOT_COUNT_POWER_OF_TWO)
        {
            var slots = new ImHashMap<K, V>[slotCountPowerOfTwo];
            for (var i = 0; i < slots.Length; ++i)
                slots[i] = ImHashMap<K, V>.Empty;
            return slots;
        }

        /// Returns a new tree with added or updated value for specified key.
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrUpdate<K, V>(this ImHashMap<K, V>[] slots, int hash, K key, V value, int hashMaskToFindSlot = HASH_MASK_TO_FIND_SLOT)
        {
            ref var slot = ref slots[hash & hashMaskToFindSlot];
            var copy = slot;
            if (Interlocked.CompareExchange(ref slot, copy.AddOrUpdate(hash, key, value), copy) != copy)
                RefAddOrUpdateSlot(ref slot, hash, key, value);
        }

        /// Returns a new tree with added or updated value for specified key.
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrUpdate<K, V>(this ImHashMap<K, V>[] slots, K key, V value, int hashMaskToFindSlot = HASH_MASK_TO_FIND_SLOT) =>
            slots.AddOrUpdate(key.GetHashCode(), key, value, hashMaskToFindSlot);

        /// Updates the ref to the slot with the new version - retry if the someone changed the slot in between
        public static void RefAddOrUpdateSlot<K, V>(ref ImHashMap<K, V> slot, int hash, K key, V value) =>
            Ref.Swap(ref slot, hash, key, value, (x, h, k, v) => x.AddOrUpdate(h, k, v));

        /// Updates the value with help of `updateValue` function
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrUpdate<K, V>(this ImHashMap<K, V>[] slots, int hash, K key, V value, Update<K, V> update, int hashMaskToFindSlot = HASH_MASK_TO_FIND_SLOT)
        {
            ref var slot = ref slots[hash & hashMaskToFindSlot];
            var copy = slot;
            if (Interlocked.CompareExchange(ref slot, copy.AddOrUpdate(hash, key, value, update), copy) != copy)
                RefAddOrUpdateSlot(ref slot, hash, key, value, update);
        }

        /// Updates the value with help of `updateValue` function
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrUpdate<K, V>(this ImHashMap<K, V>[] slots, K key, V value, Update<K, V> updateValue, int hashMaskToFindSlot = HASH_MASK_TO_FIND_SLOT) =>
            slots.AddOrUpdate(key.GetHashCode(), key, value, updateValue, hashMaskToFindSlot);

        /// Update the ref to the slot with the new version - retry if the someone changed the slot in between
        public static void RefAddOrUpdateSlot<K, V>(ref ImHashMap<K, V> slot, int hash, K key, V value, Update<K, V> update) =>
            Ref.Swap(ref slot, hash, key, value, (x, h, k, v) => x.AddOrUpdate(h, k, v, update));

        /// Adds a new value for the specified key or keeps the existing map if the key is already in the map.
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrKeep<K, V>(this ImHashMap<K, V>[] slots, int hash, K key, V value, int hashMaskToFindSlot = HASH_MASK_TO_FIND_SLOT)
        {
            ref var slot = ref slots[hash & hashMaskToFindSlot];
            var copy = slot;
            if (Interlocked.CompareExchange(ref slot, copy.AddOrKeep(hash, key, value), copy) != copy)
                RefAddOrKeepSlot(ref slot, hash, key, value);
        }

        /// Adds a new value for the specified key or keeps the existing map if the key is already in the map.
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrKeep<K, V>(this ImHashMap<K, V>[] slots, K key, V value, int hashMaskToFindSlot = HASH_MASK_TO_FIND_SLOT) =>
            slots.AddOrKeep(key.GetHashCode(), key, value, hashMaskToFindSlot);

        /// Update the ref to the slot with the new version - retry if the someone changed the slot in between
        public static void RefAddOrKeepSlot<K, V>(ref ImHashMap<K, V> slot, int hash, K key, V value) =>
            Ref.Swap(ref slot, hash, key, value, (s, h, k, v) => s.AddOrKeep(h, k, v));

        /// Updates the specified slot or does not change it
        [MethodImpl((MethodImplOptions)256)]
        public static void Update<K, V>(this ImHashMap<K, V>[] slots, int hash, K key, V value, int hashMaskToFindSlot = HASH_MASK_TO_FIND_SLOT)
        {
            ref var slot = ref slots[hash & hashMaskToFindSlot];
            var copy = slot;
            if (Interlocked.CompareExchange(ref slot, copy.Update(hash, key, value), copy) != copy)
                RefUpdateSlot(ref slot, hash, key, value);
        }

        /// Updates the specified slot or does not change it
        [MethodImpl((MethodImplOptions)256)]
        public static void Update<K, V>(this ImHashMap<K, V>[] slots, K key, V value, int hashMaskToFindSlot = HASH_MASK_TO_FIND_SLOT) =>
            slots.Update(key.GetHashCode(), key, value, hashMaskToFindSlot);

        /// Update the ref to the slot with the new version - retry if the someone changed the slot in between
        public static void RefUpdateSlot<K, V>(ref ImHashMap<K, V> slot, int hash, K key, V value) =>
            Ref.Swap(ref slot, key, value, (s, k, v) => s.Update(k, v));

        /// Returns all map tree nodes without the order
        public static S Fold<K, V, S>(this ImHashMap<K, V>[] slots, S state, Func<ImHashMapEntry<K, V>, S, S> reduce)
        {
            var parentStack = ArrayTools.Empty<ImHashMap<K, V>>();
            for (var s = 0; s < slots.Length; s++)
            {
                var map = slots[s];
                var height = map.Height;
                if (height != 0)
                {
                    if (height > 1 && parentStack.Length < height)
                        parentStack = new ImHashMap<K, V>[height];
                    state = map.Fold(state, reduce, parentStack);
                }
            }

            return state;
        }
    }
}

namespace ImTools.Experimental
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Runtime.CompilerServices;
    using System.Text;
    using System.Threading;
    /// <summary>The base class for the tree leafs and branches, also defines the Empty tree</summary>
    public class ImHashMap234<K, V>
    {
        /// <summary>Empty tree to start with.</summary>
        public static readonly ImHashMap234<K, V> Empty = new();

        /// <summary>Hide the constructor to prevent the multiple Empty trees creation</summary>
        protected ImHashMap234() { } // todo: @perf - does it hurt the perf or the call to the empty constructor is erased?

        /// Pretty-prints
        public override string ToString() => "empty " + typeof(ImHashMap234<K, V>).Name;

        /// <summary>Lookup for the entry, if not found returns `null`</summary>
        public virtual Entry GetEntryOrDefault(int hash) => null;

        /// <summary>Produces the new or updated map with the new entry</summary>
        public virtual ImHashMap234<K, V> AddOrUpdateEntry(int hash, ValueEntry entry) => entry;

        /// <summary>Produces the new map with the new entry or keeps the existing map if the entry with the key is already present</summary>
        public virtual ImHashMap234<K, V> AddOrKeepEntry(int hash, ValueEntry entry) => entry;

        /// <summary>Returns the map without the entry with the specified hash and key if it is found in the map</summary>
        public virtual ImHashMap234<K, V> RemoveEntry(int hash, K key) => this;

        /// <summary>The base entry for the Value and for the ConflictingValues entries, contains the Hash and Key</summary>
        public abstract class Entry : ImHashMap234<K, V>
        {
            /// <summary>The Hash</summary>
            public readonly int Hash;

            /// <summary>Constructs the entry with the default Key</summary>
            protected Entry(int hash) => Hash = hash; // todo: @perf think of the way to remove the base Entry constructor call - move to the inheriting classes, e.g. ValueEntry

            /// <inheritdoc />
            public sealed override Entry GetEntryOrDefault(int hash) => hash == Hash ? this : null;

            internal abstract Entry Update(ValueEntry entry);
            internal abstract Entry Keep(ValueEntry entry);
            /// <summary>returns null if entry is removed completely or modified entry, or the original entry if nothing is removed </summary>
            internal abstract Entry TryRemove<T>(T key);
        }

        /// <summary>Entry containing the Value</summary>
        public sealed class ValueEntry : Entry
        {
            /// <summary>The Key</summary>
            public readonly K Key;

            /// <summary>The value. May be modified if you need the Ref{V} semantics</summary>
            public V Value;

            /// <summary>Constructs the entry with the default value</summary>
            public ValueEntry(int hash, K key) : base(hash) => Key = key;

            /// <summary>Constructs the entry with the key and value</summary>
            public ValueEntry(int hash, K key, V value) : base(hash)
            {
                Key = key;
                Value = value;
            }

            /// <inheritdoc />
            public override string ToString() => "[" + Hash + "]" + Key + ":" + Value;

            internal override Entry Update(ValueEntry entry) =>
                Key.Equals(entry.Key) ? entry : (Entry)new ConflictsEntry(Hash, this, entry);

            internal override Entry Keep(ValueEntry entry) =>
                Key.Equals(entry.Key) ? this : (Entry)new ConflictsEntry(Hash, this, entry);

            internal override Entry TryRemove<T>(T key) =>
                Key.Equals(key) ? null : this;

            /// <inheritdoc />
            public override ImHashMap234<K, V> AddOrUpdateEntry(int hash, ValueEntry entry) =>
                hash > Hash ? new Leaf2(this, entry) :
                hash < Hash ? new Leaf2(entry, this) :
                (ImHashMap234<K, V>)Update(entry);

            /// <inheritdoc />
            public override ImHashMap234<K, V> AddOrKeepEntry(int hash, ValueEntry entry) =>
                hash > Hash ? new Leaf2(this, entry) :
                hash < Hash ? new Leaf2(entry, this) :
                (ImHashMap234<K, V>)Keep(entry);

            /// <inheritdoc />
            public override ImHashMap234<K, V> RemoveEntry(int hash, K key) =>
                hash == Hash ? TryRemove(key) ?? Empty : this;
        }

        /// <summary>Entry containing the Array of conflicting Value entries.
        /// Note: The Key field is unused and always has a default value</summary>
        public sealed class ConflictsEntry : Entry
        {
            /// <summary>The 2 and more conflicts.</summary>
            public ValueEntry[] Conflicts;

            /// <summary>Constructs the entry with the key and value</summary>
            public ConflictsEntry(int hash, params ValueEntry[] conflicts) : base(hash) => Conflicts = conflicts;

            /// <inheritdoc />
            public override string ToString()
            {
                var sb = new StringBuilder();
                foreach (var x in Conflicts)
                    sb.Append(x.ToString()).Append("; ");
                return sb.ToString();
            }

            internal override Entry Update(ValueEntry entry)
            {
                var key = entry.Key;

                var cs = Conflicts;
                var n = cs.Length;
                var i = n - 1;
                while (i != -1 && !key.Equals(cs[i].Key)) --i;

                ValueEntry[] newConflicts;
                if (i != -1) // update the found (existing) conflicted value
                {
                    newConflicts = new ValueEntry[n];
                    Array.Copy(cs, 0, newConflicts, 0, n);
                    newConflicts[i] = entry;
                }
                else // add the new conflicting value
                {
                    newConflicts = new ValueEntry[n + 1];
                    Array.Copy(cs, 0, newConflicts, 0, n);
                    newConflicts[n] = entry;
                }

                return new ConflictsEntry(Hash, newConflicts);
            }

            internal override Entry Keep(ValueEntry entry)
            {
                var key = entry.Key;

                var cs = Conflicts;
                var n = cs.Length;
                var i = n - 1;
                while (i != -1 && !key.Equals(cs[i].Key)) --i;

                ValueEntry[] newConflicts;
                if (i != -1) // return existing map
                    return this;

                newConflicts = new ValueEntry[n + 1];
                Array.Copy(cs, 0, newConflicts, 0, n);
                newConflicts[n] = entry;

                return new ConflictsEntry(Hash, newConflicts);
            }

            internal override Entry TryRemove<T>(T key)
            {
                var cs = Conflicts;
                var n = cs.Length;
                var i = n - 1;
                while (i != -1 && !key.Equals(cs[i].Key)) --i;
                if (i != -1)
                {
                    if (n == 2)
                        return i == 0 ? cs[1] : cs[0];

                    var newConflicts = new ValueEntry[n -= 1]; // the new n is less by one
                    if (i > 0) // copy the 1st part
                        Array.Copy(cs, 0, newConflicts, 0, i);
                    if (i < n) // copy the 2nd part
                        Array.Copy(cs, i + 1, newConflicts, i, n - i);

                    return new ConflictsEntry(Hash, newConflicts);
                }

                return this;
            }

            /// <inheritdoc />
            public override ImHashMap234<K, V> AddOrUpdateEntry(int hash, ValueEntry entry)
            {
                if (hash > Hash)
                    return new Leaf2(this, entry);
                if (hash < Hash)
                    return new Leaf2(entry, this);
                return Update(entry);
            }

            /// <inheritdoc />
            public override ImHashMap234<K, V> AddOrKeepEntry(int hash, ValueEntry entry)
            {
                if (hash > Hash)
                    return new Leaf2(this, entry);
                if (hash < Hash)
                    return new Leaf2(entry, this);
                return Keep(entry);
            }

            /// <inheritdoc />
            public override ImHashMap234<K, V> RemoveEntry(int hash, K key) =>
                hash == Hash ? TryRemove(key) : this;
        }

        /// <summary>Leaf with 2 entries</summary>
        public sealed class Leaf2 : ImHashMap234<K, V>
        {
            /// <summary>Left entry</summary>
            public readonly Entry Entry0;
            /// <summary>Right entry</summary>
            public readonly Entry Entry1;

            /// <summary>Constructs the leaf</summary>
            public Leaf2(Entry e0, Entry e1)
            {
                Debug.Assert(e0.Hash < e1.Hash);
                Entry0 = e0;
                Entry1 = e1;
            }

            /// <inheritdoc />
            public override string ToString() => "leaf2{" + Entry0 + "; " + Entry1 + "}";

            /// <inheritdoc />
            public override Entry GetEntryOrDefault(int hash) =>
                hash == Entry0.Hash ? Entry0 :
                hash == Entry1.Hash ? Entry1 :
                null;

            /// <inheritdoc />
            public override ImHashMap234<K, V> AddOrUpdateEntry(int hash, ValueEntry entry)
            {
                var e1 = Entry1;
                var e0 = Entry0;
                return
                    hash > e1.Hash ? new Leaf3(e0, e1, entry) :
                    hash < e0.Hash ? new Leaf3(entry, e0, e1) :
                    hash > e0.Hash && hash < e1.Hash ? new Leaf3(e0, entry, e1) :
                    hash == e0.Hash ? new Leaf2(e0.Update(entry), e1) :
                    (ImHashMap234<K, V>)new Leaf2(e0, e1.Update(entry));
            }

            /// <inheritdoc />
            public override ImHashMap234<K, V> AddOrKeepEntry(int hash, ValueEntry entry)
            {
                var e1 = Entry1;
                var e0 = Entry0;
                return
                    hash > e1.Hash ? new Leaf3(e0, e1, entry) :
                    hash < e0.Hash ? new Leaf3(entry, e0, e1) :
                    hash > e0.Hash && hash < e1.Hash ? new Leaf3(e0, entry, e1) :
                    hash == e0.Hash ? ((e0 = e0.Keep(entry)) == Entry0 ? this : new Leaf2(e0, e1)) :
                    (ImHashMap234<K, V>)((e1 = e1.Keep(entry)) == Entry1 ? this : new Leaf2(e0, e1));
            }

            /// <inheritdoc />
            public override ImHashMap234<K, V> RemoveEntry(int hash, K key)
            {
                var e0 = Entry0;
                var e1 = Entry1;
                if (hash == e0.Hash)
                    return (e0 = e0.TryRemove(key)) == Entry0 ? this : e0 == null ? e1 : (ImHashMap234<K, V>)new Leaf2(e0, e1);
                if (hash == e1.Hash)
                    return (e1 = e1.TryRemove(key)) == Entry1 ? this : e1 == null ? e0 : (ImHashMap234<K, V>)new Leaf2(e0, e1);
                return this;
            }
        }

        /// <summary>Leaf with 3 entries</summary>
        public sealed class Leaf3 : ImHashMap234<K, V>
        {
            /// <summary>Left entry</summary>
            public readonly Entry Entry0;
            /// <summary>Middle entry</summary>
            public readonly Entry Entry1;
            /// <summary>Right entry</summary>
            public readonly Entry Entry2;

            /// <summary>Constructs the leaf</summary>
            public Leaf3(Entry e0, Entry e1, Entry e2)
            {
                Debug.Assert(e0.Hash < e1.Hash);
                Debug.Assert(e1.Hash < e2.Hash);
                Entry0 = e0;
                Entry1 = e1;
                Entry2 = e2;
            }

            /// <inheritdoc />
            public override string ToString() => "leaf3{" + Entry0 + "; " + Entry1 + "; " + Entry2 + "}";

            /// <inheritdoc />
            public override Entry GetEntryOrDefault(int hash) =>
                hash == Entry0.Hash ? Entry0 :
                hash == Entry1.Hash ? Entry1 :
                hash == Entry2.Hash ? Entry2 :
                null;

            /// <inheritdoc />
            public override ImHashMap234<K, V> AddOrUpdateEntry(int hash, ValueEntry entry)
            {
                var e0 = Entry0;
                var e1 = Entry1;
                var e2 = Entry2;
                return
                    hash == e0.Hash ? new Leaf3(e0.Update(entry), e1, e2) :
                    hash == e1.Hash ? new Leaf3(e0, e1.Update(entry), e2) :
                    hash == e2.Hash ? new Leaf3(e0, e1, e2.Update(entry)) :
                    (ImHashMap234<K, V>)new Leaf3Plus1(entry, this);
            }

            /// <inheritdoc />
            public override ImHashMap234<K, V> AddOrKeepEntry(int hash, ValueEntry entry)
            {
                var e0 = Entry0;
                var e1 = Entry1;
                var e2 = Entry2;
                return
                    hash == e0.Hash ? ((e0 = e0.Keep(entry)) == Entry0 ? this : new Leaf3(e0, e1, e2)) :
                    hash == e1.Hash ? ((e1 = e1.Keep(entry)) == Entry1 ? this : new Leaf3(e0, e1, e2)) :
                    hash == e2.Hash ? ((e2 = e2.Keep(entry)) == Entry2 ? this : new Leaf3(e0, e1, e2)) :
                    (ImHashMap234<K, V>)new Leaf3Plus1(entry, this);
            }

            /// <inheritdoc />
            public override ImHashMap234<K, V> RemoveEntry(int hash, K key)
            {
                var e0 = Entry0;
                var e1 = Entry1;
                var e2 = Entry2;
                if (hash == e0.Hash)
                    return (e0 = e0.TryRemove(key)) == Entry0 ? this : e0 == null ? new Leaf2(e1, e2) : (ImHashMap234<K, V>)new Leaf3(e0, e1, e2);
                if (hash == e1.Hash)
                    return (e1 = e1.TryRemove(key)) == Entry1 ? this : e1 == null ? new Leaf2(e0, e2) : (ImHashMap234<K, V>)new Leaf3(e0, e1, e2);
                if (hash == e2.Hash)
                    return (e2 = e2.TryRemove(key)) == Entry2 ? this : e2 == null ? new Leaf2(e0, e1) : (ImHashMap234<K, V>)new Leaf3(e0, e1, e2);
                return this;
            }
        }

        /// <summary>Leaf with 3 + 1 entries</summary>
        public sealed class Leaf3Plus1 : ImHashMap234<K, V>
        {
            /// <summary>Plus entry</summary>
            public readonly Entry Plus;
            /// <summary>Dangling leaf3</summary>
            public readonly Leaf3 L3;

            /// <summary>Constructs the leaf</summary>
            public Leaf3Plus1(Entry plus, Leaf3 l3)
            {
                Plus = plus;
                L3 = l3;
            }

            /// <inheritdoc />
            public override string ToString() => "leaf3+1{" + Plus + " + " + L3 + "}";

            /// <inheritdoc />
            public override Entry GetEntryOrDefault(int hash)
            {
                if (hash == Plus.Hash)
                    return Plus;
                var l = L3;
                return
                    hash == l.Entry0.Hash ? l.Entry0 :
                    hash == l.Entry1.Hash ? l.Entry1 :
                    hash == l.Entry2.Hash ? l.Entry2 :
                    null;
            }

            /// <inheritdoc />
            public override ImHashMap234<K, V> AddOrUpdateEntry(int hash, ValueEntry entry)
            {
                var p = Plus;
                var ph = p.Hash;
                if (ph == hash)
                    return new Leaf3Plus1(p.Update(entry), L3);

                var l = L3;
                var e0 = l.Entry0;
                var e1 = l.Entry1;
                var e2 = l.Entry2;

                if (hash > e2.Hash)
                {
                    if (ph < e0.Hash)
                        return new Leaf5(p, e0, e1, e2, entry);
                    if (ph < e1.Hash)
                        return new Leaf5(e0, p, e1, e2, entry);
                    if (ph < e2.Hash)
                        return new Leaf5(e0, e1, p, e2, entry);
                    if (ph < hash)
                        return new Leaf5(e0, e1, e2, p, entry);
                    return new Leaf5(e0, e1, e2, entry, p);
                }

                if (hash < e0.Hash)
                {
                    if (ph < hash)
                        return new Leaf5(p, entry, e0, e1, e2);
                    if (ph < e0.Hash)
                        return new Leaf5(entry, p, e0, e1, e2);
                    if (ph < e1.Hash)
                        return new Leaf5(entry, e0, p, e1, e2);
                    if (ph < e2.Hash)
                        return new Leaf5(entry, e0, e1, p, e2);
                    return new Leaf5(entry, e0, e1, e2, p);
                }

                if (hash > e0.Hash && hash < e1.Hash)
                {
                    if (ph < e0.Hash)
                        return new Leaf5(p, e0, entry, e1, e2);
                    if (ph < hash)
                        return new Leaf5(e0, p, entry, e1, e2);
                    if (ph < e1.Hash)
                        return new Leaf5(e0, entry, p, e1, e2);
                    if (ph < e2.Hash)
                        return new Leaf5(e0, entry, e1, p, e2);
                    return new Leaf5(e0, entry, e1, e2, p);
                }

                if (hash > e1.Hash && hash < e2.Hash)
                {
                    if (ph < e0.Hash)
                        return new Leaf5(p, e0, e1, entry, e2);
                    if (ph < e1.Hash)
                        return new Leaf5(e0, p, e1, entry, e2);
                    if (ph < hash)
                        return new Leaf5(e0, e1, p, entry, e2);
                    if (ph < e2.Hash)
                        return new Leaf5(e0, e1, entry, p, e2);
                    return new Leaf5(e0, e1, entry, e2, p);
                }

                return
                    hash == e0.Hash ? new Leaf3Plus1(p, new Leaf3(e0.Update(entry), e1, e2)) :
                    hash == e1.Hash ? new Leaf3Plus1(p, new Leaf3(e0, e1.Update(entry), e2)) :
                                      new Leaf3Plus1(p, new Leaf3(e0, e1, e2.Update(entry)));
            }

            /// <inheritdoc />
            public override ImHashMap234<K, V> AddOrKeepEntry(int hash, ValueEntry entry)
            {
                var p = Plus;
                var ph = p.Hash;
                if (ph == hash)
                    return (p = p.Keep(entry)) == Plus ? this : new Leaf3Plus1(p, L3);

                var l = L3;
                var e0 = l.Entry0;
                var e1 = l.Entry1;
                var e2 = l.Entry2;

                if (hash > e2.Hash)
                {
                    if (ph < e0.Hash)
                        return new Leaf5(p, e0, e1, e2, entry);
                    if (ph < e1.Hash)
                        return new Leaf5(e0, p, e1, e2, entry);
                    if (ph < e2.Hash)
                        return new Leaf5(e0, e1, p, e2, entry);
                    if (ph < hash)
                        return new Leaf5(e0, e1, e2, p, entry);
                    return new Leaf5(e0, e1, e2, entry, p);
                }

                if (hash < e0.Hash)
                {
                    if (ph < hash)
                        return new Leaf5(p, entry, e0, e1, e2);
                    if (ph < e0.Hash)
                        return new Leaf5(entry, p, e0, e1, e2);
                    if (ph < e1.Hash)
                        return new Leaf5(entry, e0, p, e1, e2);
                    if (ph < e2.Hash)
                        return new Leaf5(entry, e0, e1, p, e2);
                    return new Leaf5(entry, e0, e1, e2, p);
                }

                if (hash > e0.Hash && hash < e1.Hash)
                {
                    if (ph < e0.Hash)
                        return new Leaf5(p, e0, entry, e1, e2);
                    if (ph < hash)
                        return new Leaf5(e0, p, entry, e1, e2);
                    if (ph < e1.Hash)
                        return new Leaf5(e0, entry, p, e1, e2);
                    if (ph < e2.Hash)
                        return new Leaf5(e0, entry, e1, p, e2);
                    return new Leaf5(e0, entry, e1, e2, p);
                }

                if (hash > e1.Hash && hash < e2.Hash)
                {
                    if (ph < e0.Hash)
                        return new Leaf5(p, e0, e1, entry, e2);
                    if (ph < e1.Hash)
                        return new Leaf5(e0, p, e1, entry, e2);
                    if (ph < hash)
                        return new Leaf5(e0, e1, p, entry, e2);
                    if (ph < e2.Hash)
                        return new Leaf5(e0, e1, entry, p, e2);
                    return new Leaf5(e0, e1, entry, e2, p);
                }

                return
                    hash == e0.Hash ? ((e0 = e0.Keep(entry)) == l.Entry0 ? this : (ImHashMap234<K, V>)new Leaf3Plus1(p, new Leaf3(e0, e1, e2))) :
                    hash == e1.Hash ? ((e1 = e1.Keep(entry)) == l.Entry1 ? this : (ImHashMap234<K, V>)new Leaf3Plus1(p, new Leaf3(e0, e1, e2))) :
                                      ((e2 = e2.Keep(entry)) == l.Entry2 ? this : (ImHashMap234<K, V>)new Leaf3Plus1(p, new Leaf3(e0, e1, e2)));
            }

            /// <inheritdoc />
            public override ImHashMap234<K, V> RemoveEntry(int hash, K key)
            {
                var p = Plus;
                var ph = p.Hash;
                if (ph == hash)
                    return (p = p.TryRemove(key)) == Plus ? this : p == null ? L3 : (ImHashMap234<K, V>)new Leaf3Plus1(p, L3);

                var l = L3;
                var e0 = l.Entry0;
                var e1 = l.Entry1;
                var e2 = l.Entry2;

                if (hash == e0.Hash)
                    return (e0 = e0.TryRemove(key)) == l.Entry0 ? this :
                        e0 is not null ? (ImHashMap234<K, V>)new Leaf3Plus1(p, new Leaf3(e0, e1, e2)) :
                        ph < e1.Hash ? new Leaf3(p, e1, e2) :
                        ph < e2.Hash ? new Leaf3(e1, p, e2) :
                                       new Leaf3(e1, e2, p);
                if (hash == e1.Hash)
                    return (e1 = e1.TryRemove(key)) == l.Entry1 ? this :
                        e1 is not null ? (ImHashMap234<K, V>)new Leaf3Plus1(p, new Leaf3(e0, e1, e2)) :
                        ph < e0.Hash ? new Leaf3(p, e0, e2) :
                        ph < e2.Hash ? new Leaf3(e0, p, e2) :
                                       new Leaf3(e0, e2, p);
                if (hash == e2.Hash)
                    return (e2 = e2.TryRemove(key)) == l.Entry1 ? this :
                        e2 is not null ? (ImHashMap234<K, V>)new Leaf3Plus1(p, new Leaf3(e0, e1, e2)) :
                        ph < e0.Hash ? new Leaf3(p, e0, e1) :
                        ph < e1.Hash ? new Leaf3(e0, p, e1) :
                                       new Leaf3(e0, e1, p);
                return this;
            }
        }

        /// <summary>Leaf with 5 entries</summary>
        public sealed class Leaf5 : ImHashMap234<K, V>
        {
            /// <summary>Left entry</summary>
            public readonly Entry Entry0;
            /// <summary>Middle Left entry</summary>
            public readonly Entry Entry1;
            /// <summary>Middle entry</summary>
            public readonly Entry Entry2;
            /// <summary>Middle Right entry</summary>
            public readonly Entry Entry3;
            /// <summary>Right entry</summary>
            public readonly Entry Entry4;

            /// <summary>Constructs the leaf</summary>
            public Leaf5(Entry e0, Entry e1, Entry e2, Entry e3, Entry e4)
            {
                Debug.Assert(e0.Hash < e1.Hash);
                Debug.Assert(e1.Hash < e2.Hash);
                Debug.Assert(e2.Hash < e3.Hash);
                Debug.Assert(e3.Hash < e4.Hash);
                Entry0 = e0;
                Entry1 = e1;
                Entry2 = e2;
                Entry3 = e3;
                Entry4 = e4;
            }

            /// <inheritdoc />
            public override string ToString() => "leaf5{" + Entry0 + "; " + Entry1 + "; " + Entry2 + "; " + Entry3 + "; " + Entry4 + "}";

            /// <inheritdoc />
            public override Entry GetEntryOrDefault(int hash) =>
                hash == Entry0.Hash ? Entry0 :
                hash == Entry1.Hash ? Entry1 :
                hash == Entry2.Hash ? Entry2 :
                hash == Entry3.Hash ? Entry3 :
                hash == Entry4.Hash ? Entry4 :
                null;

            /// <inheritdoc />
            public override ImHashMap234<K, V> AddOrUpdateEntry(int hash, ValueEntry entry)
            {
                var e0 = Entry0;
                var e1 = Entry1;
                var e2 = Entry2;
                var e3 = Entry3;
                var e4 = Entry4;
                return
                    hash == e0.Hash ? new Leaf5(e0.Update(entry), e1, e2, e3, e4) :
                    hash == e1.Hash ? new Leaf5(e0, e1.Update(entry), e2, e3, e4) :
                    hash == e2.Hash ? new Leaf5(e0, e1, e2.Update(entry), e3, e4) :
                    hash == e3.Hash ? new Leaf5(e0, e1, e2, e3.Update(entry), e4) :
                    hash == e4.Hash ? new Leaf5(e0, e1, e2, e3, e4.Update(entry)) :
                    (ImHashMap234<K, V>)new Leaf5Plus1(entry, this);
            }

            /// <inheritdoc />
            public override ImHashMap234<K, V> AddOrKeepEntry(int hash, ValueEntry entry)
            {
                var e0 = Entry0;
                var e1 = Entry1;
                var e2 = Entry2;
                var e3 = Entry3;
                var e4 = Entry4;
                return
                    hash == e0.Hash ? ((e0 = e0.Keep(entry)) == Entry0 ? this : new Leaf5(e0, e1, e2, e3, e4)) :
                    hash == e1.Hash ? ((e1 = e1.Keep(entry)) == Entry1 ? this : new Leaf5(e0, e1, e2, e3, e4)) :
                    hash == e2.Hash ? ((e2 = e2.Keep(entry)) == Entry2 ? this : new Leaf5(e0, e1, e2, e3, e4)) :
                    hash == e3.Hash ? ((e3 = e3.Keep(entry)) == Entry3 ? this : new Leaf5(e0, e1, e2, e3, e4)) :
                    hash == e4.Hash ? ((e4 = e4.Keep(entry)) == Entry4 ? this : new Leaf5(e0, e1, e2, e3, e4)) :
                    (ImHashMap234<K, V>)new Leaf5Plus1(entry, this);
            }

            /// <inheritdoc />
            public override ImHashMap234<K, V> RemoveEntry(int hash, K key)
            {
                var e0 = Entry0;
                var e1 = Entry1;
                var e2 = Entry2;
                var e3 = Entry3;
                var e4 = Entry4;
                if (hash == e0.Hash)
                    return (e0 = e0.TryRemove(key)) == Entry0 ? this : e0 == null ? new Leaf3Plus1(e4, new Leaf3(e1, e2, e3)) : (ImHashMap234<K, V>)new Leaf5(e0, e1, e2, e3, e4);
                if (hash == e1.Hash)
                    return (e1 = e1.TryRemove(key)) == Entry1 ? this : e1 == null ? new Leaf3Plus1(e4, new Leaf3(e0, e2, e3)) : (ImHashMap234<K, V>)new Leaf5(e0, e1, e2, e3, e4);
                if (hash == e2.Hash)
                    return (e2 = e2.TryRemove(key)) == Entry2 ? this : e2 == null ? new Leaf3Plus1(e4, new Leaf3(e0, e1, e3)) : (ImHashMap234<K, V>)new Leaf5(e0, e1, e2, e3, e4);
                if (hash == e3.Hash)
                    return (e3 = e3.TryRemove(key)) == Entry3 ? this : e3 == null ? new Leaf3Plus1(e4, new Leaf3(e0, e1, e2)) : (ImHashMap234<K, V>)new Leaf5(e0, e1, e2, e3, e4);
                if (hash == e4.Hash)
                    return (e4 = e4.TryRemove(key)) == Entry4 ? this : e4 == null ? new Leaf3Plus1(e3, new Leaf3(e0, e1, e2)) : (ImHashMap234<K, V>)new Leaf5(e0, e1, e2, e3, e4);
                return this;
            }
        }

        /// <summary>Splittable cases: Leaf5Plus1 or Branch3
        /// Note: The result of the split is always the Branch2 consisting of returned map, popEntry, and popRight</summary>
        public abstract class Leaf5Plus1OrBranch3 : ImHashMap234<K, V>
        {
            internal abstract ImHashMap234<K, V> AddOrUpdateOrSplitEntry(int hash, ValueEntry entry,
                out Entry popEntry, out ImHashMap234<K, V> popRight);

            internal abstract ImHashMap234<K, V> AddOrKeepOrSplitEntry(int hash, ValueEntry entry,
                out Entry popEntry, out ImHashMap234<K, V> popRight);
        }

        /// <summary>Leaf with 5 entries</summary>
        public sealed class Leaf5Plus1 : Leaf5Plus1OrBranch3
        {
            /// <summary>Plus entry</summary>
            public readonly Entry Plus;
            /// <summary>Dangling Leaf5</summary>
            public readonly Leaf5 L5;

            /// <summary>Constructs the leaf</summary>
            public Leaf5Plus1(Entry plus, Leaf5 l5)
            {
                Plus = plus;
                L5 = l5;
            }

            /// <inheritdoc />
            public override string ToString() => "leaf5+1{" + Plus + " + " + L5 + "}";

            /// <inheritdoc />
            public override Entry GetEntryOrDefault(int hash)
            {
                if (hash == Plus.Hash)
                    return Plus;
                var l = L5;
                return
                    hash == l.Entry0.Hash ? l.Entry0 :
                    hash == l.Entry1.Hash ? l.Entry1 :
                    hash == l.Entry2.Hash ? l.Entry2 :
                    hash == l.Entry3.Hash ? l.Entry3 :
                    hash == l.Entry4.Hash ? l.Entry4 :
                    null;
            }

            /// <inheritdoc />
            public override ImHashMap234<K, V> AddOrUpdateEntry(int hash, ValueEntry entry)
            {
                var p = Plus;
                var ph = p.Hash;
                if (ph == hash)
                    return new Leaf5Plus1(p.Update(entry), L5);

                var l = L5;
                var e0 = l.Entry0;
                var e1 = l.Entry1;
                var e2 = l.Entry2;
                var e3 = l.Entry3;
                var e4 = l.Entry4;

                if (hash > e4.Hash)
                {
                    if (ph < e0.Hash)
                        return new Branch2(new Leaf3(p, e0, e1), e2, new Leaf3(e3, e4, entry));
                    if (ph < e1.Hash)
                        return new Branch2(new Leaf3(e0, p, e1), e2, new Leaf3(e3, e4, entry));
                    if (ph < e2.Hash)
                        return new Branch2(new Leaf3(e0, e1, p), e2, new Leaf3(e3, e4, entry));
                    if (ph < e3.Hash)
                        return new Branch2(new Leaf3(e0, e1, e2), p, new Leaf3(e3, e4, entry));
                    if (ph < e4.Hash)
                        return new Branch2(new Leaf3(e0, e1, e2), e3, new Leaf3(p, e4, entry));
                    if (ph < hash)
                        return new Branch2(new Leaf3(e0, e1, e2), e3, new Leaf3(e4, p, entry));
                    return new Branch2(new Leaf3(e0, e1, e2), e3, new Leaf3(e4, entry, p));
                }

                if (hash < e0.Hash)
                {
                    if (ph < hash)
                        return new Branch2(new Leaf3(p, entry, e0), e1, new Leaf3(e2, e3, e4));
                    if (ph < e0.Hash)
                        return new Branch2(new Leaf3(entry, p, e0), e1, new Leaf3(e2, e3, e4));
                    if (ph < e1.Hash)
                        return new Branch2(new Leaf3(entry, e0, p), e1, new Leaf3(e2, e3, e4));
                    if (ph < e2.Hash)
                        return new Branch2(new Leaf3(entry, e0, e1), p, new Leaf3(e2, e3, e4));
                    if (ph < e3.Hash)
                        return new Branch2(new Leaf3(entry, e0, e1), e2, new Leaf3(p, e3, e4));
                    if (ph < e4.Hash)
                        return new Branch2(new Leaf3(entry, e0, e1), e2, new Leaf3(e3, p, e4));
                    return new Branch2(new Leaf3(entry, e0, e1), e2, new Leaf3(e3, e4, p));
                }

                if (hash > e0.Hash && hash < e1.Hash)
                {
                    if (ph < e0.Hash)
                        return new Branch2(new Leaf3(p, e0, entry), e1, new Leaf3(e2, e3, e4));
                    if (ph < hash)
                        return new Branch2(new Leaf3(e0, p, entry), e1, new Leaf3(e2, e3, e4));
                    if (ph < e1.Hash)
                        return new Branch2(new Leaf3(e0, entry, p), e1, new Leaf3(e2, e3, e4));
                    if (ph < e2.Hash)
                        return new Branch2(new Leaf3(e0, entry, e1), p, new Leaf3(e2, e3, e4));
                    if (ph < e3.Hash)
                        return new Branch2(new Leaf3(e0, entry, e1), e2, new Leaf3(p, e3, e4));
                    if (ph < e4.Hash)
                        return new Branch2(new Leaf3(e0, entry, e1), e2, new Leaf3(e3, p, e4));
                    return new Branch2(new Leaf3(e0, entry, e1), e2, new Leaf3(e3, e4, p));
                }

                if (hash > e1.Hash && hash < e2.Hash)
                {
                    if (ph < e0.Hash)
                        return new Branch2(new Leaf3(p, e0, e1), entry, new Leaf3(e2, e3, e4));
                    if (ph < e1.Hash)
                        return new Branch2(new Leaf3(e0, p, e1), entry, new Leaf3(e2, e3, e4));
                    if (ph < hash)
                        return new Branch2(new Leaf3(e0, e1, p), entry, new Leaf3(e2, e3, e4));
                    if (ph < e2.Hash)
                        return new Branch2(new Leaf3(e0, e1, entry), p, new Leaf3(e2, e3, e4));
                    if (ph < e3.Hash)
                        return new Branch2(new Leaf3(e0, e1, entry), e2, new Leaf3(p, e3, e4));
                    if (ph < e4.Hash)
                        return new Branch2(new Leaf3(e0, e1, entry), e2, new Leaf3(e3, p, e4));
                    return new Branch2(new Leaf3(e0, e1, entry), e2, new Leaf3(e3, e4, p));
                }

                if (hash > e2.Hash && hash < e3.Hash)
                {
                    if (ph < e0.Hash)
                        return new Branch2(new Leaf3(p, e0, e1), e2, new Leaf3(entry, e3, e4));
                    if (ph < e1.Hash)
                        return new Branch2(new Leaf3(e0, p, e1), e2, new Leaf3(entry, e3, e4));
                    if (ph < e2.Hash)
                        return new Branch2(new Leaf3(e0, e1, p), e2, new Leaf3(entry, e3, e4));
                    if (ph < hash)
                        return new Branch2(new Leaf3(e0, e1, e2), p, new Leaf3(entry, e3, e4));
                    if (ph < e3.Hash)
                        return new Branch2(new Leaf3(e0, e1, e2), entry, new Leaf3(p, e3, e4));
                    if (ph < e4.Hash)
                        return new Branch2(new Leaf3(e0, e1, e2), entry, new Leaf3(e3, p, e4));
                    return new Branch2(new Leaf3(e0, e1, e2), entry, new Leaf3(e3, e4, p));
                }

                if (hash > e3.Hash && hash < e4.Hash)
                {
                    if (ph < e0.Hash)
                        return new Branch2(new Leaf3(p, e0, e1), e2, new Leaf3(e3, entry, e4));
                    if (ph < e1.Hash)
                        return new Branch2(new Leaf3(e0, p, e1), e2, new Leaf3(e3, entry, e4));
                    if (ph < e2.Hash)
                        return new Branch2(new Leaf3(e0, e1, p), e2, new Leaf3(e3, entry, e4));
                    if (ph < e3.Hash)
                        return new Branch2(new Leaf3(e0, e1, e2), p, new Leaf3(e3, entry, e4));
                    if (ph < hash)
                        return new Branch2(new Leaf3(e0, e1, e2), e3, new Leaf3(p, entry, e4));
                    if (ph < e4.Hash)
                        return new Branch2(new Leaf3(e0, e1, e2), e3, new Leaf3(entry, p, e4));
                    return new Branch2(new Leaf3(e0, e1, e2), e3, new Leaf3(entry, e4, p));
                }

                return
                    hash == e0.Hash ? new Leaf5Plus1(p, new Leaf5(e0.Update(entry), e1, e2, e3, e4)) :
                    hash == e1.Hash ? new Leaf5Plus1(p, new Leaf5(e0, e1.Update(entry), e2, e3, e4)) :
                    hash == e2.Hash ? new Leaf5Plus1(p, new Leaf5(e0, e1, e2.Update(entry), e3, e4)) :
                    hash == e3.Hash ? new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3.Update(entry), e4)) :
                                      new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, e4.Update(entry)));
            }

            /// <inheritdoc />
            internal override ImHashMap234<K, V> AddOrUpdateOrSplitEntry(int hash, ValueEntry entry, out Entry popEntry, out ImHashMap234<K, V> popRight)
            {
                // todo: @perf look at what the results popEntry is set to and may be use the popEntry instead of the one of the vars above, then don't forget to use popRight on the consumer side, and remove the `popEntry = null` below
                var p = Plus;
                var ph = p.Hash;
                if (ph == hash)
                {
                    popEntry = null;
                    popRight = null;
                    return new Leaf5Plus1(p.Update(entry), L5);
                }

                var l = L5;
                var e0 = l.Entry0;
                var e1 = l.Entry1;
                var e2 = l.Entry2;
                var e3 = l.Entry3;
                var e4 = l.Entry4;

                if (hash > e4.Hash)
                {
                    if (ph < e2.Hash)
                    {
                        popEntry = e2;
                        popRight = new Leaf3(e3, e4, entry);
                        if (ph < e0.Hash)
                            return new Leaf3(p, e0, e1);
                        if (ph < e1.Hash)
                            return new Leaf3(e0, p, e1);
                        return new Leaf3(e0, e1, p);
                    }
                    if (ph < e3.Hash)
                    {
                        popEntry = p;
                        popRight = new Leaf3(e3, e4, entry);
                        return new Leaf3(e0, e1, e2);
                    }
                    popEntry = e3;
                    popRight = ph < e4.Hash ? new Leaf3(p, e4, entry) : ph < hash ? new Leaf3(e4, p, entry) : new Leaf3(e4, entry, p);
                    return new Leaf3(e0, e1, e2);
                }

                if (hash < e0.Hash)
                {
                    if (ph < e1.Hash)
                    {
                        popEntry = e1;
                        popRight = new Leaf3(e2, e3, e4);
                        if (ph < hash)
                            return new Leaf3(p, entry, e0);
                        if (ph < e0.Hash)
                            return new Leaf3(entry, p, e0);
                        return new Leaf3(entry, e0, p);
                    }
                    if (ph < e2.Hash)
                    {
                        popEntry = p;
                        popRight = new Leaf3(e2, e3, e4);
                        return new Leaf3(entry, e0, e1);
                    }
                    popEntry = e2;
                    popRight = ph < e3.Hash ? new Leaf3(p, e3, e4) : ph < e4.Hash ? new Leaf3(e3, p, e4) : new Leaf3(e3, e4, p);
                    return new Leaf3(entry, e0, e1);
                }

                if (hash > e0.Hash && hash < e1.Hash)
                {
                    if (ph < e1.Hash)
                    {
                        popEntry = e1;
                        popRight = new Leaf3(e2, e3, e4);
                        if (ph < e0.Hash)
                            return new Leaf3(p, e0, entry);
                        if (ph < hash)
                            return new Leaf3(e0, p, entry);
                        return new Leaf3(e0, entry, p);
                    }
                    if (ph < e2.Hash)
                    {
                        popEntry = p;
                        popRight = new Leaf3(e2, e3, e4);
                        return new Leaf3(e0, entry, e1);
                    }
                    popEntry = e2;
                    popRight = ph < e3.Hash ? new Leaf3(p, e3, e4) : ph < e4.Hash ? new Leaf3(e3, p, e4) : new Leaf3(e3, e4, p);
                    return new Leaf3(e0, entry, e1);
                }

                if (hash > e1.Hash && hash < e2.Hash)
                {
                    if (ph < hash)
                    {
                        popEntry = entry;
                        popRight = new Leaf3(e2, e3, e4);
                        if (ph < e0.Hash)
                            return new Leaf3(p, e0, e1);
                        if (ph < e1.Hash)
                            return new Leaf3(e0, p, e1);
                        return new Leaf3(e0, e1, p);
                    }
                    if (ph < e2.Hash)
                    {
                        popEntry = p;
                        popRight = new Leaf3(e2, e3, e4);
                        return new Leaf3(e0, e1, entry);
                    }
                    popEntry = e2;
                    popRight = ph < e3.Hash ? new Leaf3(p, e3, e4) : ph < e4.Hash ? new Leaf3(e3, p, e4) : new Leaf3(e3, e4, p);
                    return new Leaf3(e0, e1, entry);
                }

                if (hash > e2.Hash && hash < e3.Hash)
                {
                    if (ph < e2.Hash)
                    {
                        popEntry = e2;
                        popRight = new Leaf3(entry, e3, e4);
                        if (ph < e0.Hash)
                            return new Leaf3(p, e0, e1);
                        if (ph < e1.Hash)
                            return new Leaf3(e0, p, e1);
                        return new Leaf3(e0, e1, p);
                    }
                    if (ph < hash)
                    {
                        popEntry = p;
                        popRight = new Leaf3(entry, e3, e4);
                        return new Leaf3(e0, e1, e2);
                    }
                    popEntry = entry;
                    popRight = ph < e3.Hash ? new Leaf3(p, e3, e4) : ph < e4.Hash ? new Leaf3(e3, p, e4) : new Leaf3(e3, e4, p);
                    return new Leaf3(e0, e1, e2);
                }

                if (hash > e3.Hash && hash < e4.Hash)
                {
                    if (ph < e2.Hash)
                    {
                        popEntry = e2;
                        popRight = new Leaf3(e3, entry, e4);
                        if (ph < e0.Hash)
                            return new Leaf3(p, e0, e1);
                        if (ph < e1.Hash)
                            return new Leaf3(e0, p, e1);
                        return new Leaf3(e0, e1, p);
                    }
                    if (ph < e3.Hash)
                    {
                        popEntry = p;
                        popRight = new Leaf3(e3, entry, e4);
                        return new Leaf3(e0, e1, e2);
                    }
                    popEntry = e3;
                    popRight = ph < hash ? new Leaf3(p, entry, e4) : ph < e4.Hash ? new Leaf3(entry, p, e4) : new Leaf3(entry, e4, p);
                    return new Leaf3(e0, e1, e2);
                }

                popEntry = null;
                popRight = null;
                return
                    hash == e0.Hash ? new Leaf5Plus1(p, new Leaf5(e0.Update(entry), e1, e2, e3, e4)) :
                    hash == e1.Hash ? new Leaf5Plus1(p, new Leaf5(e0, e1.Update(entry), e2, e3, e4)) :
                    hash == e2.Hash ? new Leaf5Plus1(p, new Leaf5(e0, e1, e2.Update(entry), e3, e4)) :
                    hash == e3.Hash ? new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3.Update(entry), e4)) :
                                      new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, e4.Update(entry)));
            }

            /// <inheritdoc />
            public override ImHashMap234<K, V> AddOrKeepEntry(int hash, ValueEntry entry)
            {
                var p = Plus;
                var ph = p.Hash;
                if (ph == hash)
                    return (p = p.Keep(entry)) == Plus ? this : (ImHashMap234<K, V>)new Leaf5Plus1(p, L5);

                var l5 = L5;
                var e0 = l5.Entry0;
                var e1 = l5.Entry1;
                var e2 = l5.Entry2;
                var e3 = l5.Entry3;
                var e4 = l5.Entry4;

                if (hash > e4.Hash)
                {
                    if (ph < e0.Hash)
                        return new Branch2(new Leaf3(p, e0, e1), e2, new Leaf3(e3, e4, entry));
                    if (ph < e1.Hash)
                        return new Branch2(new Leaf3(e0, p, e1), e2, new Leaf3(e3, e4, entry));
                    if (ph < e2.Hash)
                        return new Branch2(new Leaf3(e0, e1, p), e2, new Leaf3(e3, e4, entry));
                    if (ph < e3.Hash)
                        return new Branch2(new Leaf3(e0, e1, e2), p, new Leaf3(e3, e4, entry));
                    if (ph < e4.Hash)
                        return new Branch2(new Leaf3(e0, e1, e2), e3, new Leaf3(p, e4, entry));
                    if (ph < hash)
                        return new Branch2(new Leaf3(e0, e1, e2), e3, new Leaf3(e4, p, entry));
                    return new Branch2(new Leaf3(e0, e1, e2), e3, new Leaf3(e4, entry, p));
                }

                if (hash < e0.Hash)
                {
                    if (ph < hash)
                        return new Branch2(new Leaf3(p, entry, e0), e1, new Leaf3(e2, e3, e4));
                    if (ph < e0.Hash)
                        return new Branch2(new Leaf3(entry, p, e0), e1, new Leaf3(e2, e3, e4));
                    if (ph < e1.Hash)
                        return new Branch2(new Leaf3(entry, e0, p), e1, new Leaf3(e2, e3, e4));
                    if (ph < e2.Hash)
                        return new Branch2(new Leaf3(entry, e0, e1), p, new Leaf3(e2, e3, e4));
                    if (ph < e3.Hash)
                        return new Branch2(new Leaf3(entry, e0, e1), e2, new Leaf3(p, e3, e4));
                    if (ph < e4.Hash)
                        return new Branch2(new Leaf3(entry, e0, e1), e2, new Leaf3(e3, p, e4));
                    return new Branch2(new Leaf3(entry, e0, e1), e2, new Leaf3(e3, e4, p));
                }

                if (hash > e0.Hash && hash < e1.Hash)
                {
                    if (ph < e0.Hash)
                        return new Branch2(new Leaf3(p, e0, entry), e1, new Leaf3(e2, e3, e4));
                    if (ph < hash)
                        return new Branch2(new Leaf3(e0, p, entry), e1, new Leaf3(e2, e3, e4));
                    if (ph < e1.Hash)
                        return new Branch2(new Leaf3(e0, entry, p), e1, new Leaf3(e2, e3, e4));
                    if (ph < e2.Hash)
                        return new Branch2(new Leaf3(e0, entry, e1), p, new Leaf3(e2, e3, e4));
                    if (ph < e3.Hash)
                        return new Branch2(new Leaf3(e0, entry, e1), e2, new Leaf3(p, e3, e4));
                    if (ph < e4.Hash)
                        return new Branch2(new Leaf3(e0, entry, e1), e2, new Leaf3(e3, p, e4));
                    return new Branch2(new Leaf3(e0, entry, e1), e2, new Leaf3(e3, e4, p));
                }

                if (hash > e1.Hash && hash < e2.Hash)
                {
                    if (ph < e0.Hash)
                        return new Branch2(new Leaf3(p, e0, e1), entry, new Leaf3(e2, e3, e4));
                    if (ph < e1.Hash)
                        return new Branch2(new Leaf3(e0, p, e1), entry, new Leaf3(e2, e3, e4));
                    if (ph < hash)
                        return new Branch2(new Leaf3(e0, e1, p), entry, new Leaf3(e2, e3, e4));
                    if (ph < e2.Hash)
                        return new Branch2(new Leaf3(e0, e1, entry), p, new Leaf3(e2, e3, e4));
                    if (ph < e3.Hash)
                        return new Branch2(new Leaf3(e0, e1, entry), e2, new Leaf3(p, e3, e4));
                    if (ph < e4.Hash)
                        return new Branch2(new Leaf3(e0, e1, entry), e2, new Leaf3(e3, p, e4));
                    return new Branch2(new Leaf3(e0, e1, entry), e2, new Leaf3(e3, e4, p));
                }

                if (hash > e2.Hash && hash < e3.Hash)
                {
                    if (ph < e0.Hash)
                        return new Branch2(new Leaf3(p, e0, e1), e2, new Leaf3(entry, e3, e4));
                    if (ph < e1.Hash)
                        return new Branch2(new Leaf3(e0, p, e1), e2, new Leaf3(entry, e3, e4));
                    if (ph < e2.Hash)
                        return new Branch2(new Leaf3(e0, e1, p), e2, new Leaf3(entry, e3, e4));
                    if (ph < hash)
                        return new Branch2(new Leaf3(e0, e1, e2), p, new Leaf3(entry, e3, e4));
                    if (ph < e3.Hash)
                        return new Branch2(new Leaf3(e0, e1, e2), entry, new Leaf3(p, e3, e4));
                    if (ph < e4.Hash)
                        return new Branch2(new Leaf3(e0, e1, e2), entry, new Leaf3(e3, p, e4));
                    return new Branch2(new Leaf3(e0, e1, e2), entry, new Leaf3(e3, e4, p));
                }

                if (hash > e3.Hash && hash < e4.Hash)
                {
                    if (ph < e0.Hash)
                        return new Branch2(new Leaf3(p, e0, e1), e2, new Leaf3(e3, entry, e4));
                    if (ph < e1.Hash)
                        return new Branch2(new Leaf3(e0, p, e1), e2, new Leaf3(e3, entry, e4));
                    if (ph < e2.Hash)
                        return new Branch2(new Leaf3(e0, e1, p), e2, new Leaf3(e3, entry, e4));
                    if (ph < e3.Hash)
                        return new Branch2(new Leaf3(e0, e1, e2), p, new Leaf3(e3, entry, e4));
                    if (ph < hash)
                        return new Branch2(new Leaf3(e0, e1, e2), e3, new Leaf3(p, entry, e4));
                    if (ph < e4.Hash)
                        return new Branch2(new Leaf3(e0, e1, e2), e3, new Leaf3(entry, p, e4));
                    return new Branch2(new Leaf3(e0, e1, e2), e3, new Leaf3(entry, e4, p));
                }

                return
                    hash == e0.Hash ? ((e0 = e0.Keep(entry)) == l5.Entry0 ? this : new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, e4))) :
                    hash == e1.Hash ? ((e1 = e1.Keep(entry)) == l5.Entry1 ? this : new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, e4))) :
                    hash == e2.Hash ? ((e2 = e2.Keep(entry)) == l5.Entry2 ? this : new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, e4))) :
                    hash == e3.Hash ? ((e3 = e3.Keep(entry)) == l5.Entry3 ? this : new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, e4))) :
                                      ((e4 = e4.Keep(entry)) == l5.Entry4 ? this : new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, e4)));
            }

            /// <inheritdoc />
            internal override ImHashMap234<K, V> AddOrKeepOrSplitEntry(int hash, ValueEntry entry,
                out Entry popEntry, out ImHashMap234<K, V> popRight)
            {
                var p = Plus;
                var ph = p.Hash;
                if (ph == hash)
                {
                    popEntry = null;
                    popRight = null;
                    return (p = p.Keep(entry)) == Plus ? this : new Leaf5Plus1(p, L5);
                }

                var l5 = L5;
                var e0 = l5.Entry0;
                var e1 = l5.Entry1;
                var e2 = l5.Entry2;
                var e3 = l5.Entry3;
                var e4 = l5.Entry4;

                if (hash > e4.Hash)
                {
                    if (ph < e2.Hash)
                    {
                        popEntry = e2;
                        popRight = new Leaf3(e3, e4, entry);
                        if (ph < e0.Hash)
                            return new Leaf3(p, e0, e1);
                        if (ph < e1.Hash)
                            return new Leaf3(e0, p, e1);
                        return new Leaf3(e0, e1, p);
                    }
                    if (ph < e3.Hash)
                    {
                        popEntry = p;
                        popRight = new Leaf3(e3, e4, entry);
                        return new Leaf3(e0, e1, e2);
                    }
                    popEntry = e3;
                    popRight = ph < e4.Hash ? new Leaf3(p, e4, entry) : ph < hash ? new Leaf3(e4, p, entry) : new Leaf3(e4, entry, p);
                    return new Leaf3(e0, e1, e2);
                }

                if (hash < e0.Hash)
                {
                    if (ph < e1.Hash)
                    {
                        popEntry = e1;
                        popRight = new Leaf3(e2, e3, e4);
                        if (ph < hash)
                            return new Leaf3(p, entry, e0);
                        if (ph < e0.Hash)
                            return new Leaf3(entry, p, e0);
                        return new Leaf3(entry, e0, p);
                    }
                    if (ph < e2.Hash)
                    {
                        popEntry = p;
                        popRight = new Leaf3(e2, e3, e4);
                        return new Leaf3(entry, e0, e1);
                    }
                    popEntry = e2;
                    popRight = ph < e3.Hash ? new Leaf3(p, e3, e4) : ph < e4.Hash ? new Leaf3(e3, p, e4) : new Leaf3(e3, e4, p);
                    return new Leaf3(entry, e0, e1);
                }

                if (hash > e0.Hash && hash < e1.Hash)
                {
                    if (ph < e1.Hash)
                    {
                        popEntry = e1;
                        popRight = new Leaf3(e2, e3, e4);
                        if (ph < e0.Hash)
                            return new Leaf3(p, e0, entry);
                        if (ph < hash)
                            return new Leaf3(e0, p, entry);
                        return new Leaf3(e0, entry, p);
                    }
                    if (ph < e2.Hash)
                    {
                        popEntry = p;
                        popRight = new Leaf3(e2, e3, e4);
                        return new Leaf3(e0, entry, e1);
                    }
                    popEntry = e2;
                    popRight = ph < e3.Hash ? new Leaf3(p, e3, e4) : ph < e4.Hash ? new Leaf3(e3, p, e4) : new Leaf3(e3, e4, p);
                    return new Leaf3(e0, entry, e1);
                }

                if (hash > e1.Hash && hash < e2.Hash)
                {
                    if (ph < hash)
                    {
                        popEntry = entry;
                        popRight = new Leaf3(e2, e3, e4);
                        if (ph < e0.Hash)
                            return new Leaf3(p, e0, e1);
                        if (ph < e1.Hash)
                            return new Leaf3(e0, p, e1);
                        return new Leaf3(e0, e1, p);
                    }
                    if (ph < e2.Hash)
                    {
                        popEntry = p;
                        popRight = new Leaf3(e2, e3, e4);
                        return new Leaf3(e0, e1, entry);
                    }
                    popEntry = e2;
                    popRight = ph < e3.Hash ? new Leaf3(p, e3, e4) : ph < e4.Hash ? new Leaf3(e3, p, e4) : new Leaf3(e3, e4, p);
                    return new Leaf3(e0, e1, entry);
                }

                if (hash > e2.Hash && hash < e3.Hash)
                {
                    if (ph < e2.Hash)
                    {
                        popEntry = e2;
                        popRight = new Leaf3(entry, e3, e4);
                        if (ph < e0.Hash)
                            return new Leaf3(p, e0, e1);
                        if (ph < e1.Hash)
                            return new Leaf3(e0, p, e1);
                        return new Leaf3(e0, e1, p);
                    }
                    if (ph < hash)
                    {
                        popEntry = p;
                        popRight = new Leaf3(entry, e3, e4);
                        return new Leaf3(e0, e1, e2);
                    }
                    popEntry = entry;
                    popRight = ph < e3.Hash ? new Leaf3(p, e3, e4) : ph < e4.Hash ? new Leaf3(e3, p, e4) : new Leaf3(e3, e4, p);
                    return new Leaf3(e0, e1, e2);
                }

                if (hash > e3.Hash && hash < e4.Hash)
                {
                    if (ph < e2.Hash)
                    {
                        popEntry = e2;
                        popRight = new Leaf3(e3, entry, e4);
                        if (ph < e0.Hash)
                            return new Leaf3(p, e0, e1);
                        if (ph < e1.Hash)
                            return new Leaf3(e0, p, e1);
                        return new Leaf3(e0, e1, p);
                    }
                    if (ph < e3.Hash)
                    {
                        popEntry = p;
                        popRight = new Leaf3(e3, entry, e4);
                        return new Leaf3(e0, e1, e2);
                    }
                    popEntry = e3;
                    popRight = ph < hash ? new Leaf3(p, entry, e4) : ph < e4.Hash ? new Leaf3(entry, p, e4) : new Leaf3(entry, e4, p);
                    return new Leaf3(e0, e1, e2);
                }

                popEntry = null;
                popRight = null;
                return
                    hash == e0.Hash ? ((e0 = e0.Keep(entry)) == l5.Entry0 ? this : new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, e4))) :
                    hash == e1.Hash ? ((e1 = e1.Keep(entry)) == l5.Entry1 ? this : new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, e4))) :
                    hash == e2.Hash ? ((e2 = e2.Keep(entry)) == l5.Entry2 ? this : new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, e4))) :
                    hash == e3.Hash ? ((e3 = e3.Keep(entry)) == l5.Entry3 ? this : new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, e4))) :
                                      ((e4 = e4.Keep(entry)) == l5.Entry4 ? this : new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, e4)));
            }

            /// <inheritdoc />
            public override ImHashMap234<K, V> RemoveEntry(int hash, K key)
            {
                var p = Plus;
                var ph = p.Hash;
                if (ph == hash)
                    return (p = p.TryRemove(key)) == Plus ? this : p == null ? L5 : (ImHashMap234<K, V>)new Leaf5Plus1(p, L5);

                var l = L5;
                var e0 = l.Entry0;
                var e1 = l.Entry1;
                var e2 = l.Entry2;
                var e3 = l.Entry3;
                var e4 = l.Entry4;

                if (hash == e0.Hash)
                    return (e0 = e0.TryRemove(key)) == l.Entry0 ? this : e0 is not null ? (ImHashMap234<K, V>)new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, e4)) :
                    ph < e1.Hash ? new Leaf5(p, e1, e2, e3, e4) :
                    ph < e2.Hash ? new Leaf5(e1, p, e2, e3, e4) :
                    ph < e3.Hash ? new Leaf5(e1, e2, p, e3, e4) :
                    ph < e4.Hash ? new Leaf5(e1, e2, e3, p, e4) :
                                   new Leaf5(e1, e2, e3, e4, p);

                if (hash == e1.Hash)
                    return (e1 = e1.TryRemove(key)) == l.Entry0 ? this : e1 is not null ? (ImHashMap234<K, V>)new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, e4)) :
                    ph < e0.Hash ? new Leaf5(p, e0, e2, e3, e4) :
                    ph < e2.Hash ? new Leaf5(e0, p, e2, e3, e4) :
                    ph < e3.Hash ? new Leaf5(e0, e2, p, e3, e4) :
                    ph < e4.Hash ? new Leaf5(e0, e2, e3, p, e4) :
                                   new Leaf5(e0, e2, e3, e4, p);

                if (hash == e2.Hash)
                    return (e2 = e2.TryRemove(key)) == l.Entry0 ? this : e2 is not null ? (ImHashMap234<K, V>)new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, e4)) :
                    ph < e0.Hash ? new Leaf5(p, e0, e1, e3, e4) :
                    ph < e1.Hash ? new Leaf5(e0, p, e1, e3, e4) :
                    ph < e3.Hash ? new Leaf5(e0, e1, p, e3, e4) :
                    ph < e4.Hash ? new Leaf5(e0, e1, e3, p, e4) :
                                   new Leaf5(e0, e1, e3, e4, p);

                if (hash == e3.Hash)
                    return (e3 = e3.TryRemove(key)) == l.Entry0 ? this : e3 is not null ? (ImHashMap234<K, V>)new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, e4)) :
                    ph < e0.Hash ? new Leaf5(p, e0, e1, e2, e4) :
                    ph < e1.Hash ? new Leaf5(e0, p, e1, e2, e4) :
                    ph < e2.Hash ? new Leaf5(e0, e1, p, e2, e4) :
                    ph < e4.Hash ? new Leaf5(e0, e1, e2, p, e4) :
                                   new Leaf5(e0, e1, e2, e4, p);

                return this;
            }
        }

        /// <summary>Branch of 2 leafs or branches</summary>
        public sealed class Branch2 : ImHashMap234<K, V>
        {
            /// <summary>Left branch</summary>
            public readonly ImHashMap234<K, V> Left;
            /// <summary>Entry in the middle</summary>
            public readonly Entry Entry0;
            /// <summary>Right branch</summary>
            public readonly ImHashMap234<K, V> Right;

            /// <summary>Constructs</summary>
            public Branch2(ImHashMap234<K, V> left, Entry e, ImHashMap234<K, V> right)
            {
                // todo: @incomplete add invariant check for the left and right both are either leafs or branches and not empty or entries
                Entry0 = e;
                Left = left;
                Right = right;
            }

            /// <inheritdoc />
            public override string ToString() =>
                !(Left is Branch2) && !(Left is Branch3) ? Left + " <- " + Entry0 + " -> " + Right :
                Left.GetType().Name + " <- " + Entry0 + " -> " + Right.GetType().Name;

            /// <inheritdoc />
            public override Entry GetEntryOrDefault(int hash) =>
                hash > Entry0.Hash ? Right.GetEntryOrDefault(hash) :
                hash < Entry0.Hash ? Left.GetEntryOrDefault(hash) :
                Entry0;

            /// <inheritdoc />
            public override ImHashMap234<K, V> AddOrUpdateEntry(int hash, ValueEntry entry)
            {
                var e0 = Entry0;
                if (hash > e0.Hash)
                {
                    if (Right is Leaf5Plus1OrBranch3 x)
                    {
                        var newBranch = x.AddOrUpdateOrSplitEntry(hash, entry, out var popEntry, out var popRight);
                        if (popRight is not null)
                            return new Branch3(Left, e0, newBranch, popEntry, popRight);
                        return new Branch2(Left, e0, newBranch);
                    }

                    return new Branch2(Left, e0, Right.AddOrUpdateEntry(hash, entry));
                }

                if (hash < e0.Hash)
                {
                    if (Left is Leaf5Plus1OrBranch3 x)
                    {
                        var newBranch = x.AddOrUpdateOrSplitEntry(hash, entry, out var popEntry, out var popRight);
                        if (popRight is not null)
                            return new Branch3(newBranch, popEntry, popRight, e0, Right);
                        return new Branch2(newBranch, e0, Right);
                    }

                    return new Branch2(Left.AddOrUpdateEntry(hash, entry), e0, Right);
                }

                return new Branch2(Left, e0.Update(entry), Right);
            }

            /// <inheritdoc />
            public override ImHashMap234<K, V> AddOrKeepEntry(int hash, ValueEntry entry)
            {
                var e0 = Entry0;
                if (hash > e0.Hash)
                {
                    ImHashMap234<K, V> newBranch;
                    if (Right is Leaf5Plus1OrBranch3 x)
                    {
                        newBranch = x.AddOrKeepOrSplitEntry(hash, entry, out var popEntry, out var popRight);
                        if (newBranch == x)
                            return this;
                        if (popRight is not null)
                            return new Branch3(Left, e0, newBranch, popEntry, popRight);
                        return new Branch2(Left, e0, newBranch);
                    }

                    newBranch = Right.AddOrKeepEntry(hash, entry);
                    return newBranch == Right ? this : new Branch2(Left, e0, newBranch);
                }

                if (hash < e0.Hash)
                {
                    ImHashMap234<K, V> newBranch;
                    if (Left is Leaf5Plus1OrBranch3 x)
                    {
                        newBranch = x.AddOrKeepOrSplitEntry(hash, entry, out var popEntry, out var popRight);
                        if (newBranch == x)
                            return this;
                        if (popRight is not null)
                            return new Branch3(newBranch, popEntry, popRight, e0, Right);
                        return new Branch2(newBranch, e0, Right);
                    }

                    newBranch = Left.AddOrKeepEntry(hash, entry);
                    return newBranch == Left ? this : new Branch2(newBranch, e0, Right);
                }

                return (e0 = e0.Keep(entry)) == Entry0 ? this : new Branch2(Left, e0, Right);
            }

            /// <inheritdoc />
            public override ImHashMap234<K, V> RemoveEntry(int hash, K key)
            {
                // Despite all the visible complexity of the method the simple check should be 
                // that all of the non-removed nodes are used when constructing the result.

                var e0 = Entry0;
                if (hash > e0.Hash)
                {
                    //        4
                    //      /   \
                    //  1 2 3   5 [6]

                    var newRight = Right.RemoveEntry(hash, key);
                    if (newRight == Right)
                        return this;

                    if (newRight is Entry re)
                    {
                        var l = Left;
                        // If the Left is not a Leaf2, move its one entry to the Right
                        if (l is Leaf3 l3)
                            return new Branch2(new Leaf2(l3.Entry0, l3.Entry1), l3.Entry2, new Leaf2(e0, re));
                        if (l is Leaf3Plus1 l4)
                        {
                            var p = l4.Plus;
                            var ph = p.Hash;
                            var l4l3 = l4.L3;
                            var l3e0 = l4l3.Entry0;
                            var l3e1 = l4l3.Entry1;
                            var l3e2 = l4l3.Entry2;

                            if (ph > l3e2.Hash)
                                return new Branch2(l4l3, p, new Leaf2(e0, re));
                            if (ph < l3e0.Hash)
                                return new Branch2(new Leaf3(p, l3e0, l3e1), l3e2, new Leaf2(e0, re));
                            if (ph < l3e1.Hash)
                                return new Branch2(new Leaf3(l3e0, p, l3e1), l3e2, new Leaf2(e0, re));
                            return new Branch2(new Leaf3(l3e0, l3e1, p), l3e2, new Leaf2(e0, re));
                        }
                        if (l is Leaf5 l5)
                            return new Branch2(new Leaf3(l5.Entry0, l5.Entry1, l5.Entry2), l5.Entry3, new Leaf3(l5.Entry4, e0, re));
                        if (l is Leaf5Plus1 l6)
                        {
                            var p = l6.Plus;
                            var ph = p.Hash;
                            var l6l5 = l6.L5;
                            var l5e0 = l6l5.Entry0;
                            var l5e1 = l6l5.Entry1;
                            var l5e2 = l6l5.Entry2;
                            var l5e3 = l6l5.Entry3;
                            var l5e4 = l6l5.Entry4;

                            if (ph > l5e4.Hash)
                                return new Branch2(l6l5, p, new Leaf2(e0, re));
                            if (ph < l5e0.Hash)
                                return new Branch2(new Leaf5(p, l5e0, l5e1, l5e2, l5e3), l5e4, new Leaf2(e0, re));
                            if (ph < l5e1.Hash)
                                return new Branch2(new Leaf5(l5e0, p, l5e1, l5e2, l5e3), l5e4, new Leaf2(e0, re));
                            if (ph < l5e2.Hash)
                                return new Branch2(new Leaf5(l5e0, l5e1, p, l5e2, l5e3), l5e4, new Leaf2(e0, re));
                            if (ph < l5e3.Hash)
                                return new Branch2(new Leaf5(l5e0, l5e1, l5e2, p, l5e3), l5e4, new Leaf2(e0, re));
                            return new Branch2(new Leaf5(l5e0, l5e1, l5e2, l5e3, p), l5e4, new Leaf2(e0, re));
                        }

                        // Case #1
                        // If the Left is Leaf2 -> reduce the whole branch to the Leaf4 and rely on the upper branch (if any) to balance itself,
                        // see this case handled below..
                        var l2 = (Leaf2)l;
                        return new Leaf3Plus1(l2.Entry0, new Leaf3(l2.Entry1, e0, re));
                    }

                    // Handling Case #1
                    if (newRight is Leaf3Plus1 && Right is Branch2) // no need to check for the Branch3 because there is no way that Leaf4 will be the result of deleting one element from it 
                    {
                        // Case #2
                        //             7                       4     7 
                        //          /      \                 /    |     \
                        //        4      8 9 10 11  =>   1 2 3   5 6   8 9 10 11
                        //      /   \                    
                        //   1 2 3   5 6                  
                        // The result tree height is decreased, so we should not forget to rebalance with the other part of the tree on the upper level
                        // see the case handled below...

                        if (Left is Branch2 lb2)
                            return new Branch3(lb2.Left, lb2.Entry0, lb2.Right, e0, newRight);

                        //                     10                            7
                        //              /           \                     /     \
                        //        4      7        11 12 13 14 =>       4          10
                        //      /     |    \                         /    \     /    \
                        //   1 2 3   5 6    8 9                   1 2 3   5 6|8 9   11 12 13 14

                        if (Left is Branch3 lb3) // the result tree height is the same - no need to rebalance
                            return new Branch2(new Branch2(lb3.Left, lb3.Entry0, lb3.Middle), lb3.Entry1, new Branch2(lb3.Right, e0, newRight));
                    }

                    // Handling the Case #2
                    if (newRight is Branch3 && Right is Branch2)
                    {
                        //         0                                  -10        0
                        //       /         \                          /     |          \                
                        //   -10           4     7                  a       b          4     7          
                        //  /   \        /    |     \               |       |        /    |     \       
                        // a     b    1 2 3   5 6   8 9 10 11   =>  ?       ?     1 2 3   5 6  8 9 10 11
                        // |     |
                        // ?     ?

                        if (Left is Branch2 lb2)
                            return new Branch3(lb2.Left, lb2.Entry0, lb2.Right, e0, newRight);

                        //              0                                       -5                           
                        //       /              \                              /     \                        
                        //   -10  -5            4      7                  -10           0                     
                        //  /   |   \          /    |     \              /   |      /        \                
                        // a    b    c   1 2 3     5 6   8 9 10 11  =>  a    b     c         4     7          
                        // |    |    |                                  |    |     |       /    |     \       
                        // ?    ?    ?                                  ?    ?     ?    1 2 3  5 6   8 9 10 11

                        if (Left is Branch3 lb3)
                            return new Branch2(
                                new Branch2(lb3.Left, lb3.Entry0, lb3.Middle),
                                lb3.Entry1,
                                new Branch2(lb3.Right, e0, newRight));
                    }

                    return new Branch2(Left, e0, newRight);
                }

                if (hash < e0.Hash)
                {
                    // todo: @wip
                }

                // todo: @wip remove the e0 and try to keep the branch until its possible
                return this;
            }
        }

        /// <summary>Branch of 3 leafs or branches and two entries</summary>
        public sealed class Branch3 : Leaf5Plus1OrBranch3
        {
            /// <summary>Left branch</summary>
            public readonly ImHashMap234<K, V> Left;
            /// <summary>Left entry</summary>
            public readonly Entry Entry0;
            /// <summary>Middle branch</summary>
            public readonly ImHashMap234<K, V> Middle;
            /// <summary>Right entry</summary>
            public readonly Entry Entry1;
            /// <summary>Rightmost branch</summary>
            public readonly ImHashMap234<K, V> Right;

            /// <summary>Constructs the branch</summary>
            public Branch3(ImHashMap234<K, V> left, Entry entry0, ImHashMap234<K, V> middle, Entry entry1, ImHashMap234<K, V> right)
            {
                // todo: @incomplete add invariant check for the left and right both are either leafs or branches and not empty or entries
                Entry0 = entry0;
                Entry1 = entry1;
                Left = left;
                Middle = middle;
                Right = right;
            }

            /// <inheritdoc />
            public override string ToString() =>
                !(Left is Branch2) && !(Left is Branch3) ? Left + " <- " + Entry0 + " -> " + Middle + " <- " + Entry1 + " -> " + Right :
                Left.GetType().Name + " <- " + Entry0 + " -> " + Middle.GetType().Name + " <- " + Entry1 + " -> " + Right.GetType().Name;

            /// <inheritdoc />
            public override Entry GetEntryOrDefault(int hash)
            {
                var h0 = Entry0.Hash;
                var h1 = Entry1.Hash;
                return
                    hash > h1 ? Right.GetEntryOrDefault(hash) :
                    hash < h0 ? Left.GetEntryOrDefault(hash) :
                    hash == h0 ? Entry0 :
                    hash == h1 ? Entry1 :
                    Middle.GetEntryOrDefault(hash);
            }

            /// <inheritdoc />
            public override ImHashMap234<K, V> AddOrUpdateEntry(int hash, ValueEntry entry)
            {
                var h0 = Entry0.Hash;
                var h1 = Entry1.Hash;

                if (hash > h1)
                {
                    // No need to call the Split method because we won't destruct the result branch
                    var newBranch = Right.AddOrUpdateEntry(hash, entry);
                    if (newBranch is Branch2 && Right is Leaf5Plus1OrBranch3)
                        return new Branch2(new Branch2(Left, Entry0, Middle), Entry1, newBranch);
                    return new Branch3(Left, Entry0, Middle, Entry1, newBranch);
                }

                if (hash < h0)
                {
                    var newBranch = Left.AddOrUpdateEntry(hash, entry);
                    if (newBranch is Branch2 && Left is Leaf5Plus1OrBranch3)
                        return new Branch2(newBranch, Entry0, new Branch2(Middle, Entry1, Right));
                    return new Branch3(newBranch, Entry0, Middle, Entry1, Right);
                }

                if (hash > h0 && hash < h1)
                {
                    if (Middle is Leaf5Plus1OrBranch3 x)
                    {
                        var newMiddle = x.AddOrUpdateOrSplitEntry(hash, entry, out var popEntry, out var popRight);
                        if (popRight is not null)
                            return new Branch2(new Branch2(Left, Entry0, newMiddle), popEntry, new Branch2(popRight, Entry1, Right));
                        return new Branch3(Left, Entry0, newMiddle, Entry1, Right);
                    }

                    return new Branch3(Left, Entry0, Middle.AddOrUpdateEntry(hash, entry), Entry1, Right);
                }

                return hash == h0
                    ? new Branch3(Left, Entry0.Update(entry), Middle, Entry1, Right)
                    : new Branch3(Left, Entry0, Middle, Entry1.Update(entry), Right);
            }

            internal override ImHashMap234<K, V> AddOrUpdateOrSplitEntry(int hash, ValueEntry entry,
                out Entry popEntry, out ImHashMap234<K, V> popRight)
            {
                var h0 = Entry0.Hash;
                var h1 = Entry1.Hash;

                if (hash > h1)
                {
                    var newRight = Right.AddOrUpdateEntry(hash, entry);
                    if (newRight is Branch2 && Right is Leaf5Plus1OrBranch3)
                    {
                        popEntry = Entry1;
                        popRight = newRight;
                        return new Branch2(Left, Entry0, Middle);
                    }

                    popEntry = null;
                    popRight = null;
                    return new Branch3(Left, Entry0, Middle, Entry1, newRight);
                }

                if (hash < h0)
                {
                    var newLeft = Left.AddOrUpdateEntry(hash, entry);
                    if (newLeft is Branch2 && Left is Leaf5Plus1OrBranch3)
                    {
                        popEntry = Entry0;
                        popRight = new Branch2(Middle, Entry1, Right);
                        return newLeft;
                    }

                    popEntry = null;
                    popRight = null;
                    return new Branch3(newLeft, Entry0, Middle, Entry1, Right);
                }

                if (hash > h0 && hash < h1)
                {
                    if (Middle is Leaf5Plus1OrBranch3 x)
                    {
                        var newMiddle = x.AddOrUpdateOrSplitEntry(hash, entry, out popEntry, out var popRightBelow);
                        if (popRightBelow is not null)
                        {
                            //                              [4]
                            //       [2, 7]            [2]         [7]
                            // [1]  [3,4,5]  [8] => [1]  [3]  [5,6]    [8]
                            // and adding 6
                            popRight = new Branch2(popRightBelow, Entry1, Right);
                            return new Branch2(Left, Entry0, newMiddle);
                        }

                        popEntry = null;
                        popRight = null;
                        return new Branch3(Left, Entry0, newMiddle, Entry1, Right);
                    }

                    popEntry = null;
                    popRight = null;
                    return new Branch3(Left, Entry0, Middle.AddOrUpdateEntry(hash, entry), Entry1, Right);
                }

                popEntry = null;
                popRight = null;
                return hash == h0
                    ? new Branch3(Left, Entry0.Update(entry), Middle, Entry1, Right)
                    : new Branch3(Left, Entry0, Middle, Entry1.Update(entry), Right);
            }

            /// <inheritdoc />
            public override ImHashMap234<K, V> AddOrKeepEntry(int hash, ValueEntry entry)
            {
                var e0 = Entry0;
                var e1 = Entry1;

                if (hash > e1.Hash)
                {
                    var newBranch = Right.AddOrKeepEntry(hash, entry);
                    if (newBranch == Right)
                        return this;
                    if (newBranch is Branch2 && Right is Leaf5Plus1OrBranch3)
                        return new Branch2(new Branch2(Left, e0, Middle), e1, newBranch);
                    return new Branch3(Left, e0, Middle, e1, newBranch);
                }

                if (hash < e0.Hash)
                {
                    var newBranch = Left.AddOrKeepEntry(hash, entry);
                    if (newBranch == Left)
                        return this;
                    if (newBranch is Branch2 && Left is Leaf5Plus1OrBranch3)
                        return new Branch2(newBranch, e0, new Branch2(Middle, e1, Right));
                    return new Branch3(newBranch, e0, Middle, e1, Right);
                }

                if (hash > e0.Hash && hash < e1.Hash)
                {
                    ImHashMap234<K, V> newMiddle;
                    if (Middle is Leaf5Plus1OrBranch3 x)
                    {
                        newMiddle = x.AddOrKeepOrSplitEntry(hash, entry, out var popEntry, out var popRight);
                        if (newMiddle == x)
                            return this;
                        if (popRight is not null)
                            return new Branch2(new Branch2(Left, e0, newMiddle), popEntry, new Branch2(popRight, e1, Right));
                        return new Branch3(Left, e0, newMiddle, e1, Right);
                    }

                    newMiddle = Middle.AddOrKeepEntry(hash, entry);
                    return newMiddle == Middle ? this : new Branch3(Left, e0, newMiddle, e1, Right);
                }

                return hash == e0.Hash
                    ? ((e0 = e0.Keep(entry)) == Entry0 ? this : new Branch3(Left, e0, Middle, e1, Right))
                    : ((e1 = e1.Keep(entry)) == Entry1 ? this : new Branch3(Left, e0, Middle, e1, Right));
            }

            internal override ImHashMap234<K, V> AddOrKeepOrSplitEntry(int hash, ValueEntry entry,
                out Entry popEntry, out ImHashMap234<K, V> popRight)
            {
                var e0 = Entry0;
                var e1 = Entry1;

                popEntry = null;
                popRight = null;

                if (hash > e1.Hash)
                {
                    var newBranch = Right.AddOrKeepEntry(hash, entry);
                    if (newBranch == Right)
                        return this;
                    if (newBranch is Branch2 && Right is Leaf5Plus1OrBranch3)
                    {
                        popEntry = e1;
                        popRight = newBranch;
                        return new Branch2(Left, e0, Middle);
                    }
                    return new Branch3(Left, e0, Middle, e1, newBranch);
                }

                if (hash < e0.Hash)
                {
                    var newBranch = Left.AddOrKeepEntry(hash, entry);
                    if (newBranch == Left)
                        return this;
                    if (newBranch is Branch2 && Left is Leaf5Plus1OrBranch3)
                    {
                        popEntry = e0;
                        popRight = new Branch2(Middle, e1, Right);
                        return newBranch;
                    }
                    return new Branch3(newBranch, e0, Middle, e1, Right);
                }

                if (hash > e0.Hash && hash < e1.Hash)
                {
                    ImHashMap234<K, V> newMiddle;
                    if (Middle is Leaf5Plus1OrBranch3 x)
                    {
                        newMiddle = x.AddOrKeepOrSplitEntry(hash, entry, out popEntry, out var popRightBelow);
                        if (newMiddle == x)
                            return this;
                        if (popRightBelow is not null)
                        {
                            //                              [4]
                            //       [2, 7]            [2]         [7]
                            // [1]  [3,4,5]  [8] => [1]  [3]  [5,6]    [8]
                            // and adding 6
                            popRight = new Branch2(popRightBelow, e1, Right);
                            return new Branch2(Left, e0, newMiddle);
                        }
                        return new Branch3(Left, e0, newMiddle, e1, Right);
                    }

                    newMiddle = Middle.AddOrKeepEntry(hash, entry);
                    return newMiddle == Middle ? this : new Branch3(Left, e0, newMiddle, e1, Right);
                }

                return hash == e0.Hash
                    ? ((e0 = e0.Keep(entry)) == Entry0 ? this : new Branch3(Left, e0, Middle, e1, Right))
                    : ((e1 = e1.Keep(entry)) == Entry1 ? this : new Branch3(Left, e0, Middle, e1, Right));
            }

            /// <inheritdoc />
            public override ImHashMap234<K, V> RemoveEntry(int hash, K key)
            {
                var e1 = Entry1;
                if (hash > e1.Hash)
                {
                    var newRight = Right.RemoveEntry(hash, key);
                    if (newRight == Right)
                        return this;

                    // if we done to the single entry - rebalance the entries
                    if (newRight is Entry re)
                    {
                        //      3       7               3
                        //    /     |     \    =>    /      \
                        //  1 2   3 5 6     8      1 2   3 5 6 7 8
                        var m = Middle;

                        // If the Middle is Leaf2 or Leaf3 - merge the Middle with new Right to the Branch2
                        if (m is Leaf2 l2)
                            return new Branch2(Left, Entry0, new Leaf3Plus1(l2.Entry0, new Leaf3(l2.Entry1, e1, re)));
                        if (m is Leaf3 l3)
                            return new Branch2(Left, Entry0, new Leaf5(l3.Entry0, l3.Entry1, l3.Entry2, e1, re));

                        // Rebalance the entries from Middle to the Right
                        if (m is Leaf3Plus1 l4)
                        {
                            var p = l4.Plus;
                            var ph = p.Hash;
                            var l4l3 = l4.L3;
                            var l3e0 = l4l3.Entry0;
                            var l3e1 = l4l3.Entry1;
                            var l3e2 = l4l3.Entry2;

                            if (ph > l3e2.Hash)
                                return new Branch3(Left, Entry0, l4l3, p, new Leaf2(e1, re));
                            if (ph < l3e0.Hash)
                                return new Branch3(Left, Entry0, new Leaf3(p, l3e0, l3e1), l3e2, new Leaf2(e1, re));
                            if (ph < l3e1.Hash)
                                return new Branch3(Left, Entry0, new Leaf3(l3e0, p, l3e1), l3e2, new Leaf2(e1, re));
                            return new Branch3(Left, Entry0, new Leaf3(l3e0, l3e1, p), l3e2, new Leaf2(e1, re));
                        }

                        if (m is Leaf5 l5)
                            return new Branch3(Left, Entry0, new Leaf3Plus1(l5.Entry0, new Leaf3(l5.Entry1, l5.Entry2, l5.Entry3)), l5.Entry4, new Leaf2(e1, re));

                        {
                            var l6 = (Leaf5Plus1)m;
                            var p = l6.Plus;
                            var ph = p.Hash;
                            var l6l5 = l6.L5;
                            var l5e0 = l6l5.Entry0;
                            var l5e1 = l6l5.Entry1;
                            var l5e2 = l6l5.Entry2;
                            var l5e3 = l6l5.Entry3;
                            var l5e4 = l6l5.Entry4;

                            if (ph > l5e4.Hash)
                                return new Branch3(Left, Entry0, l6l5, p, new Leaf2(e1, re));
                            if (ph < l5e0.Hash)
                                return new Branch3(Left, Entry0, new Leaf5(p, l5e0, l5e1, l5e2, l5e3), l5e4, new Leaf2(e1, re));
                            if (ph < l5e1.Hash)
                                return new Branch3(Left, Entry0, new Leaf5(l5e0, p, l5e1, l5e2, l5e3), l5e4, new Leaf2(e1, re));
                            if (ph < l5e2.Hash)
                                return new Branch3(Left, Entry0, new Leaf5(l5e0, l5e1, p, l5e2, l5e3), l5e4, new Leaf2(e1, re));
                            if (ph < l5e3.Hash)
                                return new Branch3(Left, Entry0, new Leaf5(l5e0, l5e1, l5e2, p, l5e3), l5e4, new Leaf2(e1, re));
                            return new Branch3(Left, Entry0, new Leaf5(l5e0, l5e1, l5e2, l5e3, p), l5e4, new Leaf2(e1, re));
                        }
                    }

                    // The only reason for moving from the Branch3 to the Branch2 is the decreased the tree height so we need to rebalance
                    if (newRight is Branch3 && Right is Branch2)
                    {
                        //      1       7                                   1
                        //    /     |         \                           /    \
                        //   ?      b        10    13                   ?     b     7
                        //  / \    / \      /    |    \                 |    /   |     \
                        // ?   ?  a   c   8 9  11 12  14 15  =>         ?   a    c   10   13
                        // |   |  |   |                                 
                        // ?   ?  ?   ?                                                ...
                        if (Middle is Branch2 mb2) // just dangle the new right together with Middle
                            return new Branch2(Left, Entry0, new Branch3(mb2.Left, mb2.Entry0, mb2.Right, e1, newRight));

                        //      -15             0                                 -15          -5                              
                        //    /         |              \                          /       |         \                          
                        // -20       -10  -5             4      7              -20       -10           0                       
                        //  |       /   |   \          /    |     \             |        /   \       /        \                
                        //  x      a    b    c   1 2 3     5 6   8 9 10 11  =>  ?       a     b     c        4     7           
                        //  |      |    |    |                                  |       |     |     |      /    |     \        
                        //  ?      ?    ?    ?                                  ?       ?     ?     ?    1 2 3  5 6   8 9 10 11
                        if (Middle is Branch3 mb3)
                            return new Branch3(Left, Entry0,
                                new Branch2(mb3.Left, mb3.Entry0, mb3.Middle), mb3.Entry1, new Branch2(mb3.Right, e1, newRight));
                    }

                    return new Branch3(Left, Entry0, Middle, Entry1, newRight);
                }

                var e0 = Entry0;
                if (hash < e0.Hash)
                {
                    // todo: @wip
                }

                if (hash > e0.Hash && hash < e1.Hash)
                {
                    // todo: @wip
                }

                if (hash == e0.Hash)
                {
                    // todo: @wip
                }

                //if (hash == e1.Hash)
                // todo: @wip


                return this;
            }
        }
    }

    /// <summary>ImMap methods</summary>
    public static class ImHashMap234
    {
        /// <summary>Looks up for the key using its hash code and checking the key with `object.Equals` for equality,
        ///  returns found value or the default value if not found</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<K, V>(this ImHashMap234<K, V> map, int hash, K key)
        {
            var e = map.GetEntryOrDefault(hash);
            if (e is ImHashMap234<K, V>.ValueEntry v)
            {
                if (v.Key.Equals(key))
                    return v.Value;
            }
            else if (e is ImHashMap234<K, V>.ConflictsEntry c)
            {
                foreach (var x in c.Conflicts)
                    if (x.Key.Equals(key))
                        return x.Value;
            }
            return default;
        }

        /// <summary>Looks up for the key using its hash code and checking the key with `object.Equals` for equality,
        /// returns found value or the default value if not found</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<K, V>(this ImHashMap234<K, V> map, K key) =>
            map.GetValueOrDefault(key.GetHashCode(), key);

        /// <summary>Looks up for the key using its hash code and checking the key with `object.ReferenceEquals` for equality,
        ///  returns found value or the default value if not found</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefaultReferenceEqual<K, V>(this ImHashMap234<K, V> map, int hash, K key) where K : class
        {
            var e = map.GetEntryOrDefault(hash);
            if (e is ImHashMap234<K, V>.ValueEntry v)
            {
                if (v.Key == key)
                    return v.Value;
            }
            else if (e is ImHashMap234<K, V>.ConflictsEntry c)
            {
                foreach (var x in c.Conflicts)
                    if (x.Key == key)
                        return x.Value;
            }
            return default;
        }

        /// <summary>Looks up for the key using its hash code and checking the key with `object.Equals` for equality,
        /// returns the `true` and the found value or `false`</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<K, V>(this ImHashMap234<K, V> map, int hash, K key, out V value)
        {
            var e = map.GetEntryOrDefault(hash);
            if (e is ImHashMap234<K, V>.ValueEntry v)
            {
                if (v.Key.Equals(key))
                {
                    value = v.Value;
                    return true;
                }
            }
            else if (e is ImHashMap234<K, V>.ConflictsEntry c)
            {
                foreach (var x in c.Conflicts)
                    if (x.Key.Equals(key))
                    {
                        value = x.Value;
                        return true;
                    }
            }

            value = default;
            return false;
        }

        /// <summary>Looks up for the key using its hash code and checking the key equality with the `ReferenceEquals`, 
        /// returns the `true` and the found value or `false`</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFindReferenceEqual<K, V>(this ImHashMap234<K, V> map, int hash, K key, out V value) where K : class
        {
            var e = map.GetEntryOrDefault(hash);

            if (e is ImHashMap234<K, V>.ValueEntry v)
            {
                if (v.Key == key)
                {
                    value = v.Value;
                    return true;
                }
            }
            else if (e is ImHashMap234<K, V>.ConflictsEntry c)
            {
                foreach (var x in c.Conflicts)
                    if (x.Key == key)
                    {
                        value = x.Value;
                        return true;
                    }
            }

            value = default;
            return false;
        }

        /// <summary>Looks up for the key using its hash code and returns the `true` and the found value or `false`</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<K, V>(this ImHashMap234<K, V> map, K key, out V value) =>
            map.TryFind(key.GetHashCode(), key, out value);

        /// <summary>Adds or updates the value by key in the map, always returning the modified map.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap234<K, V> AddOrUpdate<K, V>(this ImHashMap234<K, V> map, int hash, K key, V value) =>
            map.AddOrUpdateEntry(hash, new ImHashMap234<K, V>.ValueEntry(hash, key, value));

        /// <summary>Adds or updates the value by key in the map, always returning the modified map.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap234<K, V> AddOrUpdate<K, V>(this ImHashMap234<K, V> map, K key, V value)
        {
            var hash = key.GetHashCode();
            return map.AddOrUpdateEntry(hash, new ImHashMap234<K, V>.ValueEntry(hash, key, value));
        }

        /// <summary>Produces the new map with the new entry or keeps the existing map if the entry with the key is already present</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap234<K, V> AddOrKeep<K, V>(this ImHashMap234<K, V> map, int hash, K key, V value) =>
            map.AddOrKeepEntry(hash, new ImHashMap234<K, V>.ValueEntry(hash, key, value));

        /// <summary>Produces the new map with the new entry or keeps the existing map if the entry with the key is already present</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap234<K, V> AddOrKeep<K, V>(this ImHashMap234<K, V> map, K key, V value)
        {
            var hash = key.GetHashCode();
            return map.AddOrKeepEntry(hash, new ImHashMap234<K, V>.ValueEntry(hash, key, value));
        }

        /// <summary>Returns the map without the entry with the specified hash and key if it is found in the map.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap234<K, V> Remove<K, V>(this ImHashMap234<K, V> map, int hash, K key) =>
            map.RemoveEntry(hash, key);

        /// <summary>Returns the map without the entry with the specified hash and key if it is found in the map.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap234<K, V> Remove<K, V>(this ImHashMap234<K, V> map, K key) =>
            // it make sense to have the condition here to prevent the probably costly `GetHashCode()` for the empty map.
            map == ImHashMap234<K, V>.Empty ? map : map.RemoveEntry(key.GetHashCode(), key);

        // todo: @wip incomplete, does not consider Conflicts yet
        /// <summary>
        /// Enumerates all the map nodes from the left to the right and from the bottom to top
        /// You may pass `parentStacks` to reuse the array memory.
        /// NOTE: the length of `parentStack` should be at least of map (height - 2) - the stack want be used for 0, 1, 2 height maps,
        /// the content of the stack is not important and could be erased.
        /// </summary>
        public static IEnumerable<ImHashMap234<K, V>.ValueEntry> Enumerate<K, V>(this ImHashMap234<K, V> map, List<ImHashMap234<K, V>> parentStack = null)
        {
            if (map == ImHashMap234<K, V>.Empty)
                yield break;
            if (map is ImHashMap234<K, V>.Entry e)
            {
                if (e is ImHashMap234<K, V>.ValueEntry v) yield return v;
                else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)e).Conflicts) yield return c;
                yield break;
            }
            // todo: @perf add a single check for the branch to prevent multiple checks for the leafs in case of bug tree
            {
                if (map is ImHashMap234<K, V>.Leaf2 l2)
                {
                    if (l2.Entry0 is ImHashMap234<K, V>.ValueEntry v0) yield return v0;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l2.Entry0).Conflicts) yield return c;
                    if (l2.Entry1 is ImHashMap234<K, V>.ValueEntry v1) yield return v1;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l2.Entry1).Conflicts) yield return c;
                    yield break;
                }
                if (map is ImHashMap234<K, V>.Leaf3 l3)
                {
                    if (l3.Entry0 is ImHashMap234<K, V>.ValueEntry v0) yield return v0;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l3.Entry0).Conflicts) yield return c;
                    if (l3.Entry1 is ImHashMap234<K, V>.ValueEntry v1) yield return v1;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l3.Entry1).Conflicts) yield return c;
                    if (l3.Entry2 is ImHashMap234<K, V>.ValueEntry v2) yield return v2;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l3.Entry2).Conflicts) yield return c;
                    yield break;
                }
                if (map is ImHashMap234<K, V>.Leaf3Plus1 l31)
                {
                    var p = l31.Plus;
                    var l = l31.L3;
                    if (p.Hash < l.Entry0.Hash)
                        if (p is ImHashMap234<K, V>.ValueEntry pv) yield return pv;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)p).Conflicts) yield return c;
                    else
                        if (l.Entry0 is ImHashMap234<K, V>.ValueEntry v) yield return v;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l.Entry0).Conflicts) yield return c;
                    if (p.Hash < l.Entry1.Hash)
                        if (p is ImHashMap234<K, V>.ValueEntry pv) yield return pv;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)p).Conflicts) yield return c;
                    else
                        if (l.Entry1 is ImHashMap234<K, V>.ValueEntry v) yield return v;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l.Entry1).Conflicts) yield return c;
                    if (p.Hash < l.Entry2.Hash)
                        if (p is ImHashMap234<K, V>.ValueEntry pv) yield return pv;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)p).Conflicts) yield return c;
                    else
                    {
                        if (l.Entry2 is ImHashMap234<K, V>.ValueEntry v) yield return v;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l.Entry2).Conflicts) yield return c;
                        if (p is ImHashMap234<K, V>.ValueEntry pv) yield return pv;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)p).Conflicts) yield return c;
                    }
                    yield break;
                }
                if (map is ImHashMap234<K, V>.Leaf5 l5)
                {
                    if (l5.Entry0 is ImHashMap234<K, V>.ValueEntry v0) yield return v0;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l5.Entry0).Conflicts) yield return c;
                    if (l5.Entry1 is ImHashMap234<K, V>.ValueEntry v1) yield return v1;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l5.Entry1).Conflicts) yield return c;
                    if (l5.Entry2 is ImHashMap234<K, V>.ValueEntry v2) yield return v2;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l5.Entry2).Conflicts) yield return c;
                    if (l5.Entry3 is ImHashMap234<K, V>.ValueEntry v3) yield return v3;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l5.Entry3).Conflicts) yield return c;
                    if (l5.Entry4 is ImHashMap234<K, V>.ValueEntry v4) yield return v4;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l5.Entry4).Conflicts) yield return c;
                    yield break;
                }
                if (map is ImHashMap234<K, V>.Leaf5Plus1 l51)
                {
                    var p = l51.Plus;
                    var l = l51.L5;
                    if (p.Hash < l.Entry0.Hash)
                        if (p is ImHashMap234<K, V>.ValueEntry pv) yield return pv;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)p).Conflicts) yield return c;
                    else
                        if (l.Entry0 is ImHashMap234<K, V>.ValueEntry v) yield return v;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l.Entry0).Conflicts) yield return c;
                    if (p.Hash < l.Entry1.Hash)
                        if (p is ImHashMap234<K, V>.ValueEntry pv) yield return pv;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)p).Conflicts) yield return c;
                    else
                        if (l.Entry1 is ImHashMap234<K, V>.ValueEntry v) yield return v;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l.Entry1).Conflicts) yield return c;
                    if (p.Hash < l.Entry2.Hash)
                        if (p is ImHashMap234<K, V>.ValueEntry pv) yield return pv;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)p).Conflicts) yield return c;
                    else
                        if (l.Entry2 is ImHashMap234<K, V>.ValueEntry v) yield return v;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l.Entry2).Conflicts) yield return c;
                    if (p.Hash < l.Entry3.Hash)
                        if (p is ImHashMap234<K, V>.ValueEntry pv) yield return pv;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)p).Conflicts) yield return c;
                    else
                        if (l.Entry3 is ImHashMap234<K, V>.ValueEntry v) yield return v;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l.Entry3).Conflicts) yield return c;
                    if (p.Hash < l.Entry4.Hash)
                        if (p is ImHashMap234<K, V>.ValueEntry pv) yield return pv;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)p).Conflicts) yield return c;
                    else
                    {
                        if (l.Entry4 is ImHashMap234<K, V>.ValueEntry v) yield return v;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l.Entry4).Conflicts) yield return c;
                        if (p is ImHashMap234<K, V>.ValueEntry pv) yield return pv;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)p).Conflicts) yield return c;
                    }
                    yield break;
                }
            }
            var parentIndex = -1;
            while (true)
            {
                if (map is ImHashMap234<K, V>.Branch2 b2)
                {
                    var lb = b2.Left;
                    if (lb is ImHashMap234<K, V>.Branch2 || lb is ImHashMap234<K, V>.Branch3)
                    {
                        if (parentStack == null)
                            parentStack = new List<ImHashMap234<K, V>>();
                        if (parentStack.Count > ++parentIndex)
                            parentStack[parentIndex] = map;
                        else
                            parentStack.Add(map);
                        map = lb;
                    }
                }
                else if (map is ImHashMap234<K, V>.Branch3 b3)
                {
                    var lb = b3.Left;
                    if (lb is ImHashMap234<K, V>.Branch2 || lb is ImHashMap234<K, V>.Branch3)
                    {
                        if (parentStack == null)
                            parentStack = new List<ImHashMap234<K, V>>();
                        if (parentStack.Count > ++parentIndex)
                            parentStack[parentIndex] = map;
                        else
                            parentStack.Add(map);
                        map = lb;
                    }
                }

                if (map is ImHashMap234<K, V>.Leaf2 l2)
                {
                    if (l2.Entry0 is ImHashMap234<K, V>.ValueEntry v0) yield return v0;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l2.Entry0).Conflicts) yield return c;
                    if (l2.Entry1 is ImHashMap234<K, V>.ValueEntry v1) yield return v1;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l2.Entry1).Conflicts) yield return c;
                }
                else if (map is ImHashMap234<K, V>.Leaf3 l3)
                {
                    if (l3.Entry0 is ImHashMap234<K, V>.ValueEntry v0) yield return v0;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l3.Entry0).Conflicts) yield return c;
                    if (l3.Entry1 is ImHashMap234<K, V>.ValueEntry v1) yield return v1;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l3.Entry1).Conflicts) yield return c;
                    if (l3.Entry2 is ImHashMap234<K, V>.ValueEntry v2) yield return v2;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l3.Entry2).Conflicts) yield return c;
                }
                else if (map is ImHashMap234<K, V>.Leaf3Plus1 l31)
                {
                    var p = l31.Plus;
                    var l = l31.L3;
                    if (p.Hash < l.Entry0.Hash)
                        if (p is ImHashMap234<K, V>.ValueEntry pv) yield return pv;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)p).Conflicts) yield return c;
                    else
                        if (l.Entry0 is ImHashMap234<K, V>.ValueEntry v) yield return v;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l.Entry0).Conflicts) yield return c;
                    if (p.Hash < l.Entry1.Hash)
                        if (p is ImHashMap234<K, V>.ValueEntry pv) yield return pv;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)p).Conflicts) yield return c;
                    else
                        if (l.Entry1 is ImHashMap234<K, V>.ValueEntry v) yield return v;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l.Entry1).Conflicts) yield return c;
                    if (p.Hash < l.Entry2.Hash)
                        if (p is ImHashMap234<K, V>.ValueEntry pv) yield return pv;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)p).Conflicts) yield return c;
                    else
                    {
                        if (l.Entry2 is ImHashMap234<K, V>.ValueEntry v) yield return v;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l.Entry2).Conflicts) yield return c;
                        if (p is ImHashMap234<K, V>.ValueEntry pv) yield return pv;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)p).Conflicts) yield return c;
                    }
                }
                else if (map is ImHashMap234<K, V>.Leaf5 l5)
                {
                    if (l5.Entry0 is ImHashMap234<K, V>.ValueEntry v0) yield return v0;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l5.Entry0).Conflicts) yield return c;
                    if (l5.Entry1 is ImHashMap234<K, V>.ValueEntry v1) yield return v1;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l5.Entry1).Conflicts) yield return c;
                    if (l5.Entry2 is ImHashMap234<K, V>.ValueEntry v2) yield return v2;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l5.Entry2).Conflicts) yield return c;
                    if (l5.Entry3 is ImHashMap234<K, V>.ValueEntry v3) yield return v3;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l5.Entry3).Conflicts) yield return c;
                    if (l5.Entry4 is ImHashMap234<K, V>.ValueEntry v4) yield return v4;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l5.Entry4).Conflicts) yield return c;
                    yield break;
                }
                else if (map is ImHashMap234<K, V>.Leaf5Plus1 l51)
                {
                    var p = l51.Plus;
                    var l = l51.L5;
                    if (p.Hash < l.Entry0.Hash)
                        if (p is ImHashMap234<K, V>.ValueEntry pv) yield return pv;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)p).Conflicts) yield return c;
                    else
                        if (l.Entry0 is ImHashMap234<K, V>.ValueEntry v) yield return v;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l.Entry0).Conflicts) yield return c;
                    if (p.Hash < l.Entry1.Hash)
                        if (p is ImHashMap234<K, V>.ValueEntry pv) yield return pv;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)p).Conflicts) yield return c;
                    else
                        if (l.Entry1 is ImHashMap234<K, V>.ValueEntry v) yield return v;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l.Entry1).Conflicts) yield return c;
                    if (p.Hash < l.Entry2.Hash)
                        if (p is ImHashMap234<K, V>.ValueEntry pv) yield return pv;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)p).Conflicts) yield return c;
                    else
                        if (l.Entry2 is ImHashMap234<K, V>.ValueEntry v) yield return v;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l.Entry2).Conflicts) yield return c;
                    if (p.Hash < l.Entry3.Hash)
                        if (p is ImHashMap234<K, V>.ValueEntry pv) yield return pv;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)p).Conflicts) yield return c;
                    else
                        if (l.Entry3 is ImHashMap234<K, V>.ValueEntry v) yield return v;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l.Entry3).Conflicts) yield return c;
                    if (p.Hash < l.Entry4.Hash)
                        if (p is ImHashMap234<K, V>.ValueEntry pv) yield return pv;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)p).Conflicts) yield return c;
                    else
                    {
                        if (l.Entry4 is ImHashMap234<K, V>.ValueEntry v) yield return v;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)l.Entry4).Conflicts) yield return c;
                        if (p is ImHashMap234<K, V>.ValueEntry pv) yield return pv;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)p).Conflicts) yield return c;
                    }
                }

                if (parentIndex == -1)
                    break; // we yield the leaf and there is nothing in stack - we are done!

                var child = map;
                map = parentStack[parentIndex]; // otherwise get the parent
                if (map is ImHashMap234<K, V>.Branch2 pb2)
                {
                    if (pb2.Entry0 is ImHashMap234<K, V>.ValueEntry v) yield return v;
                    else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)pb2.Entry0).Conflicts) yield return c;
                    map = pb2.Right;
                    --parentIndex; // we done with the this level handled the Left (previously) and the Right (now)
                }
                else
                {
                    var pb3 = (ImHashMap234<K, V>.Branch3)map;
                    if (child == pb3.Left)
                    {
                        if (pb3.Entry0 is ImHashMap234<K, V>.ValueEntry v) yield return v;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)pb3.Entry0).Conflicts) yield return c;
                        map = pb3.Middle; // we don't modify parentIndex here because we are not done with this level yet - there is still a Right branch
                    }
                    else
                    {
                        if (pb3.Entry1 is ImHashMap234<K, V>.ValueEntry v) yield return v;
                        else foreach (var c in ((ImHashMap234<K, V>.ConflictsEntry)pb3.Entry1).Conflicts) yield return c;
                        map = pb3.Right;
                        --parentIndex; // we done with the this level handled the Left and the Middle (previously) and the Right (now)
                    }
                }
            }
        }
    }

    /// <summary>
    /// The fixed array of maps (partitions) where the first key bits are used to locate the partion to lookup into.
    /// Note: The partition array is NOT immutable and operates by swapping the updated partition (map) with the new one.
    /// The default partitions count it "carefully selected" to be 16:
    /// - Not too big to waste the space for the small collection and to fit (hopefully) into the cache line (16 of 4 byte pointer = 64 bytes)
    /// - Not too short to diminish the benifits of partioning
    /// </summary>
    public static class PartitionedHashMap234
    {
        /// <summary>Default number of partions</summary>
        public const int PART_COUNT_POWER_OF_TWO = 16;

        /// <summary>The default mask to partition the key</summary>
        public const int PART_HASH_MASK = PART_COUNT_POWER_OF_TWO - 1;

        /// <summary>Creates the new collection with the empty partions</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap234<K, V>[] CreateEmpty<K, V>(int partCountPowerOfTwo = PART_COUNT_POWER_OF_TWO)
        {
            var parts = new ImHashMap234<K, V>[partCountPowerOfTwo];
            for (var i = 0; i < parts.Length; ++i)
                parts[i] = ImHashMap234<K, V>.Empty;
            return parts;
        }

        /// <summary>Returns THE SAME partitioned map BUT with updated partion</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrUpdate<K, V>(this ImHashMap234<K, V>[] parts, int hash, K key, V value, int partHashMask = PART_HASH_MASK)
        {
            ref var part = ref parts[hash & partHashMask];
            var p = part;
            if (Interlocked.CompareExchange(ref part, p.AddOrUpdate(hash, key, value), p) != p)
                RefAddOrUpdatePart(ref part, hash, key, value);
        }

        /// <summary>Returns THE SAME partitioned map BUT with updated partion</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrUpdate<K, V>(this ImHashMap234<K, V>[] parts, K key, V value, int partHashMask = PART_HASH_MASK) =>
            parts.AddOrUpdate(key.GetHashCode(), key, value, partHashMask);

        /// <summary>Updates the ref to the part with the new version and retries if the someone changed the part in between</summary>
        public static void RefAddOrUpdatePart<K, V>(ref ImHashMap234<K, V> part, int hash, K key, V value) =>
            Ref.Swap(ref part, hash, key, value, (x, h, k, v) => x.AddOrUpdate(h, k, v));
    }
}

#pragma warning restore